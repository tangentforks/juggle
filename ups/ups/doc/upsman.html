<HTML>

<HEAD>
<TITLE>ups.man</TITLE>
<META name="description" content="The UPS debugger for C, C++ and Fortran - manual page (HTML version)">
</HEAD>

<BODY bgcolor=#F0F0F0 text=#000000 link=#0000ff vlink=#C000C0 alink=#ff0000>
<!-- $Id: upsman.html,v 1.1.1.1 2001/01/27 23:32:40 neitzel Exp $ -->
<!-- .\" @(#)ups.man	3.33 17 Aug 1998 -->
<!-- .\" @(#)ups.man	3.34 11 Mar 1999 -->
<!-- .\" @(#)ups.man	3.34 20 May 1999 -->
<small>
Originally generated by
<A HREF="http://www.parallax.co.uk/~rolf/download/manServer.html">manServer</A>
from the `ups' manual page.
Subsequently hacked about by <a href="ups@concerto.demon.co.uk">Ian Edwards</a>.
Last updated : 12th June 2000 - for <b>ups</b> 3.35beta11
</small>

<div align=CENTER>
<A NAME="TOP"><H1><hr><I>Manual Reference Pages &nbsp;-&nbsp;</I>UPS&nbsp;(1)<hr></H1></A>
</div>

<!-- NAME ----------------------------------------------------------------- -->

<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<h1>ups - X11 and SunView based source level C debugger</h1>
</td></tr></table>
<p>

<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<h1>Version <font color=red>3.35beta11</font></h1>
</td></tr></table>
<p>

<!-- CONTENTS ------------------------------------------------------------- -->

<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<A name="CONTENTS"><H3>CONTENTS</H3></A>
</td></tr></table>

<BLOCKQUOTE>
<a href="#CONTENTS">Contents</A><br>
<a href="#SYNOPSIS">Synopsis</A><br>
<a href="#DESCRIPTION">Description</A><br>
<br>
<a href="#GETTING STARTED">Getting Started</a><br>
<a href="#UPS COMMAND LINE ARGUMENTS">UPS Command Line Arguments</a><br>
<a href="#ENVIRONMENT VARIABLES AFFECTING UPS">Environment Variables Affecting UPS</a><br>
<a href="#INTERACTIVELY ADDING SEARCH PATHS">Interactively Adding Search Paths</a><br>
<br>
<a href="#LAYOUT OF THE UPS WINDOW">Layout of the UPS window</a><br>
<a href="#THE DISPLAY AREA">The Display Area</a><br>
<a href="#THE SOURCE REGION">The Source Region</a><br>
<a href="#FILE NAME BOX">File Name Box</a><br>
<a href="#EDITABLE FIELDS">Editable Fields</a><br>
<a href="#EDIT HISTORY">Edit History</a><br>
<a href="#CUT AND PASTE">Cut and Paste</a><br>
<a href="#EDITING IN THE OUTPUT WINDOW">Editing in the Output Window</a><br>
<a href="#LISTING MATCHING SYMBOLS FOR BREAKPOINTS">Listing Matching Symbols For Breakpoints</a><br>
<br>
<a href="#EXAMINING THE TARGETS STATE">Examining The Target&acute;s State</a><br>
<a href="#EXAMINING VARIABLE VALUES">Examining Variable Values</a><br>
<a href="#ACCELERATORS IN THE DISPLAY AREA">Accelerators in the Display Area</a><br>
<a href="#SOURCE FILES MENU">Source Files Menu</a><br>
<a href="#BREAKPOINT MENUS">Breakpoint Menus</a><br>
<a href="#SPECIAL HANDLING FOR SIGSEGV AND SIGBUS">Special handling for <tt>SIGSEGV</tt> and <tt>SIGBUS</tt></a><br>
<a href="#CONTROLLING TARGET EXECUTION">Controlling Target Execution</a><br>
<a href="#THE TYPING LINE MENUS">The Typing Line Menus</a><br>
<a href="#TARGET COMMAND LINE ARGUMENTS">Target Command Line Arguments</a><br>
<br>
<a href="#CONTROLLING THE DISPLAY OF VARIABLES">Controlling The Display Of Variables</a><br>
<a href="#CHANGING VARIABLE VALUES">Changing Variable Values</a><br>
<a href="#EXPRESSIONS IN THE DISPLAY AREA">Expressions in the Display Area</a><br>
<a href="#EXAMINING BASE CLASSES AND VECTOR TABLES">Examining Base Classes and Vector Tables</a><br>
<a href="#EXAMINING STATIC MEMBERS OF CLASSES">Examining Static Members of Classes</a><br>
<a href="#PASTING EXPRESSIONS FROM THE SOURCE WINDOW">Pasting Expressions from the Source Window</a><br>
<a href="#ADDING INTERPRETED CODE">Adding Interpreted Code</a><br>
<a href="#EXAMINING LINKED DATA STRUCTURES">Examining Linked Data Structures</a><br>
<a href="#DISPLAYING MEMORY">Displaying Memory</a><br>
<br>
<a href="#ENVIRONMENT VARIABLES">Environment Variables</a><br>
<a href="#SIGNALS">Signals</a><br>
<br>
<a href="#TYPING LINE SHORTCUTS">Typing Line Shortcuts</a><br>
<a href="#X AND SUNVIEW COMMAND LINE FLAGS">X and SunView Command Line Flags</a><br>
<a href="#X RESOURCES">X Resources</a><br>
<br>
<a href="#DEBUGGING FORTRAN CODE">Debugging FORTRAN Code</a><br>
<a href="#SUPPORT FOR C++">Support for C++</a><br>
<a href="#SUPPORT FOR ROGUE WAVE RWCStrings">Support for Rogue Wave RWCStrings</a><br>
<a href="#INITIALIZATION FILE">Initialization File</a><br>
<a href="#MULTIPLE LINKED FILES">Multiple Linked Files</a><br>
<a href="#SAVING STATE">Saving State</a><br>
<a href="#LOADING AND SAVING BREAKPOINTS">Loading And Saving Breakpoints</a><br>
<br>
<a href="#SEE ALSO">See Also</a><br>
<a href="#BUGS">Bugs</a><br>
<a href="#ACKNOWLEDGEMENTS">Acknowledgements</a><br>
<a href="#AUTHORS">Authors</a><br>
<a href="#ENHANCEMENT AUTHORS">Enhancement Authors</a><br>
</BLOCKQUOTE>
<hr>

<!-- SYNOPSIS ------------------------------------------------------------- -->

<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<A name="SYNOPSIS"><H3>SYNOPSIS</H3></A>
</td></tr></table>

<p>
<big>
<B>ups</B>
&nbsp;&nbsp;<I>target</I>
&nbsp;&nbsp;[&nbsp;<I>corefile</I>&nbsp;|&nbsp;<I>pid</I>&nbsp;]
&nbsp;&nbsp;[&nbsp;[:]<I>srcdir</I>[:<I>srcdir</I>&nbsp;]&nbsp;]
&nbsp;&nbsp;[&nbsp;<B>-a</B>&nbsp;&nbsp;<I>target-args</I>&nbsp;]
</big>
</p>
<hr>

<!-- DESCRIPTION ---------------------------------------------------------- -->

<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<A name="DESCRIPTION"><H3>DESCRIPTION</H3></A>
</td></tr></table>

<p>
<I>Ups</I> is a X based source level debugger for the C, C++ and Fortran
programming languages.
It supports both run time debugging with breakpoints and post&shy;mortem
debugging from a core file.
On Suns you can attach <I>ups</I> to a running process.
<I>Ups</I> runs in its own window,
thus not interfering with the target program&acute;s I/O.
The <I>ups</I> window has two major areas &shy; one showing a structured
document representing the target state, the other showing the source
that is being executed.

<p>
<I>Ups</I> makes heavy use of direct manipulation and feedback.
When you add a breakpoint it is shown as a pseudo C statement
(<TT>#stop</TT>)
in the source display.
The current point of execution is highlighted in the source display
and you can watch it move as you step through loops and function calls.
You can edit in fragments of interpreted C code (including assignments
to variables and calls to target functions).
There are powerful facilities for exploring linked data structures &shy;
you can recursively expand and collapse structures to follow links.

<p>
<I>Ups</I> is primarily a C debugger,
but it also has support for debugging Fortran 77 and Fortran 90 code.
See the section
<a href="#DEBUGGING FORTRAN CODE"><small>DEBUGGING FORTRAN CODE</small></a>
for information on Fortran specific features.

<p>
<I>Ups</I> has reasonable support of C++.
See the section
<a href="#SUPPORT FOR C++"><small>SUPPORT FOR C++</small></a>
for information on on this.
</P>

<P>
The URL for the <I>ups</i> web site is
<blockquote>
<a href="http://www.concerto.demon.co.uk/UPS/">http://www.concerto.demon.co.uk/UPS/</a>
</blockquote>
It is maintained by Ian Edwards
(<a href="mailto:ian@concerto.demon.co.uk">ian@concerto.demon.co.uk</a>).
It includes a FAQ, html man pages, site listings where ups
can be found, supported architectures, a history of changes 
between versions and other information.
</P>

<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->


<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<a name="GETTING STARTED"><H3>GETTING STARTED</H3></a>
</td></tr></table>

<p>
This is covered in the document <a href="getstart.html">Getting started with UPS</a>.
</p>

<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->

<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<a name="UPS COMMAND LINE ARGUMENTS"><H3>UPS COMMAND LINE ARGUMENTS</H3></a>
</td></tr></table>

<p>
This section gives a complete description of the command line
arguments accepted by
<I>ups</I>.
The command line syntax is :

<blockquote>
<B>ups</B>
<I>target</I>
[<I>corefile</I>|<I>pid</I>]
[[:]<I>srcdir</I>[:<I>srcdir</I>]]
[<B>-a</B> <I>target-args</I>]
[<B>-nodemangle</B>]
[<B>-nosavesigs</B>]
[<B>-split</B>[:<I>screen</I>]]
[<B>-fullpath</B>]
</blockquote>

<I>Ups</I> accepts various other flags, but these are mostly to support
maintenance and testing, and are not of interest to the
general user.
You can see a full list of the
<I>ups</I> flags by giving the command
<TT>ups</tt>&nbsp;<tt>-fullusage</TT>.

<p>
The only mandatory argument is the name of the executable file
containing the program to be debugged (the target).

<p>
If a <I>corefile</I> argument is given it is taken to be the name of
a core image dumped from <I>target</I>.
If no <I>corefile</I> argument is given and there is a core image file
called <tt>core</TT> in the directory of the target then that is taken as
the core file.
Old core files, and core files which weren&acute;t dumped from the target, are
silently ignored unless you give the name of the core file explicitly
(in which case
<I>ups</I> will use it, but give a warning message).

<p>
If the <I>corefile</I> argument consists solely of digits,
it is taken to be the process id of the target.
This allows you to attach
<I>ups</I> to an already running process on machines
with the necessary support (currently only Suns).
If you subsequently quit <I>ups</I> while still attached in this way,
it detaches from the target, allowing the target to continue.

<p>
By default
<I>ups</I> looks for source files in the directory of the target.
You can specify alternative source directories by giving a list of directories
separated by <tt>:</tt> characters.
An empty initial path (<i>i.e.</i> a leading <tt>:</tt>) means the directory of the
target.
On Suns running SunOS 4, the C compiler includes directory paths for
source files, so
<I>ups</I> will normally find source files in other
directories even without the source path argument.

<p>
You can specify the arguments that the target should be invoked with by
giving the
<B>-a</B> option, followed by a single argument.
You can give multiple arguments for the target by enclosing the list of
arguments in single or double quotes.
<I>Ups</I> will itself interpret metacharacters like
<tt>*</TT> and <tt>&gt;</TT> - see
<a href="#TARGET COMMAND LINE ARGUMENTS"><small>TARGET COMMAND LINE ARGUMENTS</small></a>.

<p>
When the <tt>-nodemangle</tt> argument is specified,
<I>ups</I> will do no demangling on function or variable names.
This should
result is slightly faster invocation time for pure C code.
It is still
possible to debug C++ code in this mode, although the names need some
mental deciphering.
A unique feature of this version of <I>ups</I>, is that
even when C++ names are shown mangled, you can generally still click
on variables in the source window, and <I>ups</I> will still find the name
to display, albeit in a mangled state.

<p>
If you are saving state between debugging sessions by creating a
<tt>ups-state</tt> directory, the command option, <tt>-nosavesigs</tt>
stops <i>ups</i> from saving signal state to the ups state file.
</P>

<P>
By default, <I>ups</i> passes only the final component of the <I>target</I>
filename to the process as <tt>argv[0]</tt>. Sometimes, the process needs the
full path to itself, for example, to locate auxiliary files.
If the <tt>-fullpath</tt>
argument is specified, this default behaviour is suppressed and the <I>target</i>
filename is passed directly from the ups command line to the process
command line.
</P>

<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->

<table width=100% bgcolor=#ffffcc border=0 cellspacing=0>
<tr><td>&nbsp;</td></tr><tr><td align=center>
<a name="ENVIRONMENT VARIABLES AFFECTING UPS"><H3>ENVIRONMENT VARIABLES AFFECTING UPS</H3></a>
</td></tr>
</table>

<p>
You can see all the symbol table names that are loaded and not loaded by doing a
<tt>setenv&nbsp;VERBOSE&nbsp;1</tt> before calling <I>ups</I>.
Setting <tt>VERBOSE</tt> to <tt>NOLOAD</tt> causes
to list just the libraries that are not loaded.

<p>
Most software projects of any size develop formal or informal naming conventions
that make it possible to specify the desired format for a variable based on the
name and, possibly, the type, regardless of the context in which it appears.
If, like most software engineers, you spend much of your time debugging the same
code, you can set up a <tt>UPS_FORMATS</tt> string in your environment to specify
the desired formats for frequently examined variables.

<p>
The following is an example of a <tt>UPS_FORMATS</tt> string :
<blockquote>
<PRE>
export UPS_FORMATS="                                  \
     unsigned : UHEX;   /* Default unsigned to hex */ \
     unsigned *any_int[NTLW] : UDML;                  \
     char abyte: OCT;                                 \
     *bits* : UBIN;                                   \
     auto "
</PRE>
</blockquote>

<p>
The first line of this format string causes <I>ups</I> to format unsigned variables
in hex rather than decimal.
The format string accepts C-style comments
to allow for more readable <tt>.login</tt> or <tt>.cshrc</tt> files.

<p>
The second line specifies that any unsigned
variable whose name matches the string <tt>*any_int[NTLW]</tt> is an exception
and should be formatted in decimal.
Pattern matching is as in shells such
as <I>sh</I>, <I>csh</I>, or <I>bash</I>.
<blockquote>
It is important that the exception come after the general rule specified
in the first line.
</blockquote>

<p>
Note that in the <tt>UPS_FORMATS</tt> string, <tt>char *foo</tt>
means any variable of type char whose name ends in <tt>foo</tt>, not a variable
named <tt>foo</tt> of type <tt>char*</tt>.

<p>
The third line specifies that any variable of type <tt>char</tt> and name <tt>abyte</tt>
should be formatted in octal.

<p>
The forth line specifies that any variable of any basic type with the
string <tt>bits</tt> in its name should be formatted in binary.

<p>
The last line specifies that any time the you change a format <I>ups</I> should
automatically save the change and use it as the default format for any
variable of the same name and type.

<p>
The syntax of the <tt>UPS_FORMATS</tt> string is :

<p>
<div align=center><table width = 90%>
<tr>
    <td><i>format_string</i></td>
    <td><tt>::=</tt></td>
    <td><i>format_spec</i> [ <tt>;</tt> <i>format_string</i>] [<tt>;</tt>]</td>
</tr>
<tr>
    <td><i>format_spec</i></td>
    <td><tt>::=</tt></td>
    <td><i>format_request</i> | <i>auto_save_request</i></td>
</tr>
<tr>
    <td><i>format_request</i></td>
    <td><tt>::=</tt></td>
    <td>[ <tt>unsigned</tt> ] [ <i>type</i> ] [ <i>pattern</i> ] <tt>:</tt> [ <i>format</i> ]</td>
</tr>
<tr>
    <td><i>type</i></td>
    <td><tt>::=</tt></td>
    <td><tt>char<tt> | <tt>short</tt> | <tt>int</tt> | <tt>long</tt></td>
</tr>
<tr>
    <td><i>pattern</i></td>
    <td><tt>::=</tt></td>
    <td>any C identifier with wild cards <tt>*</tt>, <tt>?</tt> or <tt>[]</tt></td>
</tr>
<tr>
    <td><i>format</i></td>
    <td><tt>::=</tt></td>
    <td><tt>UHEX</tt> | <tt>UOCT</tt> | <tt>UDML</tt> | <tt>UBIN</tt> | <tt>HEX</tt> | <tt>OCT</tt> | <tt>DML</tt> | <tt>ASCII</tt> | <tt>STRING</tt></td>
</tr>
<tr>
    <td><i>auto_save_request</i></td>
    <td><tt>::=</tt></td>
    <td><tt>auto</tt></td>
</tr>
</table></div>
</p>

<p>
In the format request, if the type is omitted then either all unsigned basic
types or all basic types regardless of sign are selected.
If the pattern is
omitted the default pattern is <tt>*</tt> so that all variables of the specified type
are selected.

<p>
It is possible to insert pre-defined strings when editing text.
This applies to all editing : in the typing line, in the display area, in
breakpoint code and in the output window.
The right mouse button invokes a menu of strings defined by
environment variables of name <tt>UPS_F*_STR</tt>
where <tt>*</tt> is a number from 1 through 12.
When the cursor is over the typing line or output window,
the mousehole shows "(menu)" for the right button as an indication
that a custom menu may be available.

<p>
The <tt>UPS_F*_STR</tt> strings accept control, meta, and escape characters
as follows :

<p>
<div align=center><table width = 90%>
<tr>
    <td>\n, \r, or \e</td>
    <td>Enter an escape character to terminate the edit</td>
</tr>
<tr>
    <td>^A, ^B, <i>etc.</i></td>
    <td>Enter the corresponding control character</td>
</tr>
<tr>
    <td>@f, @b, <i>etc.</i></td>
    <td>Enter the corresponding meta character. This allows movement by words</td>
</tr>
<tr>
    <td>\\ or \^ or \@</td>
    <td>Override the special meaning of <tt>\</tt> or <tt>^</tt></td>
</tr>
</table></div>

<p>
As an example, it is often nice to have skeleton strings for <tt>printf()</tt>
or <tt>cout</tt> statements in breakpoint code, or a directive for expanding
linked lists for the typing line, or a string for setting breakpoints
on <tt>cout</tt> statements in C++ code.
Yet another string can be used to
call <tt>strcmp()</tt> for a conditional breakpoint.
The F6 string pastes in the X-windows
selection and the F7 string sets a breakpoint in <i>purified</i> code.

<p>
To do this, put the following in your environment :
<blockquote>
<pre>
setenv UPS_F1_STR &acute;$printf("\\n");&acute;
setenv UPS_F2_STR &acute;if (strcmp(, ""))&acute;
setenv UPS_F3_STR &acute;@name .next&acute;
setenv UPS_F4_STR "ostream::operator&lt;&lt;"
setenv UPS_F5_STR &acute;ostream::operator&lt;&lt;(&cout, "");&acute;
setenv UPS_F6_STR "^e^u^y\n"
setenv UPS_F7_STR "%b purify_stop_here\n"
</pre>
</blockquote>
</P>

<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->


<table width=100% bgcolor=#ffffcc border=0 cellspacing=0>
<tr><td>&nbsp;</td></tr><tr><td align=center>
<a name="INTERACTIVELY ADDING SEARCH PATHS"><H3>INTERACTIVELY ADDING SEARCH PATHS</H3></a>
</td></tr>
</table>

<p>
Search paths can be given to <I>ups</I> at any time during debug by
selecting the <tt>Source Files</tt> header in the display window and
pressing <B>Add source path</B>.
The typing line will prompt for input.
It will display the last entry in the search path list as a default, if
a list exists.
Multiple paths may be entered at once by entering a
colon separated list.
This is the same syntax as the <I>ups</I> command line
arguments.
This enables the paths for source files to be found without
the need to back out of the
debugger and add the search path to the command line.
Note that this will
work only if the file is already an entry in the source file list, but
cannot be listed.
When this condition occurs, pressing the <b>path</b> caption
will display the assumed path for the file, which must be in error.
The program may have to be statically linked to find all source file names.
</P>

<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->

<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<a name="LAYOUT OF THE UPS WINDOW"><H3>LAYOUT OF THE UPS WINDOW</H3></a>
</td></tr></table>

<p>
The
<I>ups</I> window is divided into a number of rectangular regions.
This section gives a brief description of each region.

<p>
<div align=center>
<a href="ups_key.gif" target="_blank"><img border=1 src="ups_key.gif" alt="It won&acute;t make much sense unless you
are also looking at an ups window."></a>
<br>
<small>Click on the picture to open it in a new window.</small>
</div>
</p>

<p>
<ul>
<li>
    At the top of the window on the left is the <I>typing line</I>.
    On startup a black rectangle known as a <I>editing cursor</I> is shown.
    Typed characters appear in this region, and some
    <I>ups</I> commands
    use the text in this window as an argument (<i>e.g.</i>, the command to
    search for a regular expression in a source file).
<p>
<li>
    Below the typing line is the <I>dynamic menu area</I>.
    On startup this area may be greyed out (it is not if colours have
    been set for the <i>ups</i> windows).
    See
    <a href="#THE DISPLAY AREA"><small>THE DISPLAY AREA</small></a>
    below for a description of the dynamic menu.
<p>
<li>
    Below the dynamic menu area is a region where messages from
    <I>ups</I> appear (usually with a beep).
<p>
<li>
    To the right of the above three regions is a <I>mousehole</I>.
    This has a representation of the three mouse buttons, and captions
    for each button saying what that button will do.
    The captions change as you move from region to region, reflecting
    the fact that the mouse buttons have different functions in
    different regions.
<p>
<li>
    Below the preceding four regions is the <I>display area</I> -
    a large region used to display and investigate the current state
    of the target.
    There is a scroll bar to the left of the display area.
    See
    <a href="#THE DISPLAY AREA"><small>THE DISPLAY AREA</small></a>.
<p>
<li>
    Below the display area is the <I>target menu</I>.
    This has a set of commands for controlling target execution.
    See
    <a href="#CONTROLLING TARGET EXECUTION"><small>CONTROLLING TARGET EXECUTION</small></a>
    below.
<p>
<li>
    Below the target menu is the <I>source menu</I>, with a set of commands
    for managing the source region, which is below this menu.
    There is a scroll bar to the left of the source region.
    See
    <a href="#THE SOURCE REGION"><small>THE SOURCE REGION</small></a>
    below.
</ul>
</p>

<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->

<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<a name="THE DISPLAY AREA"><H3>THE DISPLAY AREA</H3></a>
</td></tr></table>

<p>
The display area is the large region in the upper half of the
<I>ups</I> window.
Its main use is to show the state of the program when it stopped,
though it is also used for other control functions.

<p>
There are a number of captions in the display area,
like
<B>Signals</B>,
<B>Breakpoints</B>
<i>etc.</i>
These are known as <I>objects</I>.
To select an object, press and release the left mouse button over it.

<p>
Any objects that were previously selected are deselected,
the object is inverted to show that it is selected, and a menu
of commands applicable to that object appears
in the second of the three slots at the top of the window.
At any time this region of the display either contains a menu
corresponding to a selected object, or is empty (painted a
uniform grey) if there are no objects selected.

<p>
A command selected from the menu (by pressing and releasing the
left mouse button over the caption) is applied to the currently
selected objects.
It is possible to apply a command to a group of objects.
To do this, select a group of objects
by pressing the left mouse button over the
first object and then dragging the mouse over the other objects
you wish to select before releasing the button.
You cannot select objects of different types simultaneously
as each different type of object has its own menu.
Once the first object has been selected, only objects of the
same type will be selected (and highlighted) as the cursor passes
over them.

<p>
The right hand mouse button is used to toggle whether an object
is selected - clicking it over a selected object deselects
that object, and clicking over an object that isn&acute;t selected adds
that object to the selection.
As with the left mouse button, you can drag the mouse with
the right button down to toggle a group of objects.

<p>
Several of the menu commands add new objects to the display.
For example, when you expand an entry in the stack trace
all the local variables for the function it represents
are added to the display (see
<a href="#EXAMINING VARIABLE VALUES"><small>EXAMINING VARIABLE VALUES</small></a>
below).
These new objects can be selected in the same way as the
existing ones, and have an associated menu of commands.

<p>
Once a few objects have been added to the display area,
there is usually not enough room to display all of them
at once.
There is a scroll bar to the left of the display area
which lets you scroll the display area up and down.
To scroll, press and hold down the left mouse button whilst within
the scroll bar, and move the mouse in the direction you
wish the display to move.
The further you move the mouse, the faster the scrolling.

<p>
You can also use the left and right mouse buttons to page up and down
through the display in the same way as with the
<i>xterm(1)</i>
scroll bar.
Clicking the left mouse button in the scroll bar pages the display
down.
Similarly, clicking the right button pages the display up.
The distance paged depends on how far the cursor is from the top of
the scroll bar.

<p>
The black blob in the scroll bar represents the proportion
of the entire display that is currently visible, and the
position of this visible part within the whole display.
For example, if the black blob is one third the height
of the scroll bar, and in the middle, it means that
the total height of the objects is about three times
the height of the display area, and the middle third
is currently being displayed.

<p>
You can use the scroll bar to go directly to a given
point in the display.
Press and release the middle mouse button at a point in the
scroll bar.
The black blob is moved so that it centres around the
point, and the display is moved correspondingly.
</P>

<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->

<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<a name="THE SOURCE REGION"><H3>THE SOURCE REGION</H3></a>
</td></tr></table>

<p>
The source region is used to display the source line that the target
is currently stopped at, or more precisely the line that is about to
be executed.
Like the display area, the source region has a scroll bar to the
left of it, which behaves in the same way as the display area
scroll bar.

<p>
Above and to the left of the source region is a box where the name
of the current source file and the current line number is
displayed.
See the
<a href="#FILE NAME BOX"><small>FILE NAME BOX</small></a>
section for details of the right button menu for this region.

<p>
To the right of this is the source region menu with commands
<B>Back</B>,
<B>Search</B>,
<B>Up</B>
and
<B>Down</B>.

<p>
The
<B>Up</B>
and
<B>Down</B>
commands step up and down through the target program&acute;s call stack.
If you are looking at the source code of the currently executing
function,
<B>Up</B>
switches the display to show the source of the function that called it.
Repeatedly clicking on
<B>Up</B>
will take you all the way up the stack to
<TT>main</TT>
(or
<TT>MAIN</TT>
for Fortran programs).
Similarly,
<B>Down</B>
steps one level down in the call stack.

<p>
When <I>ups</I> has been attached to a target, it is possible to
detach without quitting the debugger by pressing
the <B>Detach</B> caption at the bottom of the display window.
At a later time, <I>ups</I> can then
be attached to the same instance of the target, or to a new instance
of the target by using the attach caption described below.
<!--
A useful application of this is for
targets that dynamically relink themselves with the Sun
<tt>dlopen()</tt>, <tt>dlsym()</tt>, and <tt>dlclose()</tt> routines.
As the debugger must not be attached during the relink
these command allow the debugger
to be quickly detached before the relink, and then reattached afterwards.
-->

<p>
On an attach, the debugger will reload any shared libraries that have
changed, as well as any new shared libraries that the target uses.
If <I>ups</I> has been detached from the target as described above, or if
the target terminates for any reason, it is possible to attach
to the same or a new invocation of the target without quitting the debugger.
The
advantage of this is that it may take several minutes for <I>ups</I> to
initially come up, but once the symbol tables have been read, the
time to reattach will be at most, of the order of tens of seconds,
and often just a few seconds.
All breakpoints and even breakpoint code
will still work.
After pressing <B>Attach</B> you will be prompted to
enter the PID number.
The PID of the last attached process
is displayed as a default.
If the new invocation of the target has changed,
the reattached session may not work correctly if statically linked
object files have changed.
<I>ups</I> will re-read any changed shared libraries
when attaching.

<p>
A very handy use of the <b>Attach</b> item is for debugging spawned
processes that can timeout unless a communications handshake or license
check is performed quickly.
If the spawned process is stopped at a pause
while <I>ups</I> is invoked from scratch, the process may well timeout and exit
before <I>ups</I> can read all the necessary symbol information.
The solution is to first invoke <I>ups</I> on the target without a PID in the command
line.
After the symbols have been read, breakpoints can be set, then the
real process to be debugged is spawned.
Then press <B>Attach</B> and
quickly enter the PID of the spawned process to debug.

<p>
Shared libraries are reloaded if they change between attach/detach cycles.
So one can attach to a target, debug, detach and then rebuild a shared library
that the target uses.
Then after the target is rerun with the new library, <I>ups</I>
can be attached again and the new library will be re-scanned
and debugging can continue without quitting <I>ups</I>, and without the overhead
of re-reading symbols for the other libraries.
Breakpoints in the new library will need to be reset.
<I>Ups</I> puts out a message about what
libraries are being reloaded in such cases.

<p>
The
<B>Search</B>
command is used to search for regular expressions
(using the same syntax as <I>grep(1)</I> patterns) in the currently
displayed source file.
First type in the pattern to be searched for (typed characters appear
in the typing line at the top of the window on the left) then
press and hold down the left mouse button over the
<B>Search</B>
caption.
A popup menu appears with the options
<B>Backwards</B>
and
<B>Forwards</B>.
Move the mouse over the one you want and release the button.
If the pattern is found, the matching text is made visible in the
source region and highlighted.

<p>
You can click the left mouse button on any variable or function name in the
source window to display it.
Variables are added to the display area, as described in
<a href="#EXAMINING VARIABLE VALUES"><small>EXAMINING VARIABLE VALUES</small></a>
below.
If you click on a function name, the source for that function is displayed
(this is similar to the tags facility in
<I>emacs</I> or <I>vi</I>).
<I>Ups</I> maintains a stack of where you&acute;ve been.
After you have clicked on a function name you can use the
<B>Back</B>
command in the source menu to return to where you were.

<p>
You can also get a function displayed by typing the name into the
typing line at the top of the
<I>ups</I> window.
You do not need to type the whole name - just enough characters to
uniquely identify the function.
As for typing in a breakpoint, pressing
ESC does partial name completion, and Shift-ESC, or Shift-RETURN will list
the matching
names in the output window.
If a function appears by the same name in more than one source file,
you can use the syntax <tt>filename:funcname</tt> to specify which function
you want.
<I>Ups</I> will also understand shell-style globbing with <tt>*</tt>(<i>e.g.</i>
<tt>*foo_func*</TT>)
for function and global
variable names, with the restriction that the pattern must match only
a single name.

<p>
Whenever the source region switches to a new source file,
<I>ups</I> checks the last modified time of the source file against
the last modified time of the target object file.
If the source file is newer than the target you get a warning
message and the source code is displayed with foreground and background
colours reversed as a reminder that this source code might not
correspond the object file you are debugging.
See the section
<a href="#FILE NAME BOX"><small>FILE NAME BOX</small></a>
below this for getting actual file dates.

<p>
You can select arbitrary text in the source window by dragging the
mouse over it with the left button pressed.
The selected text is highlighted, and can be pasted into other
windows, or other areas in the ups window (such as the typing line).
Note that dragging (press mouse button, move mouse, release) has a
different effect than clicking (pressing and releasing the left mouse
button without moving the mouse).
</P>

<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->

<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<a name="FILE NAME BOX"><H3>FILE NAME BOX</H3></a>
</td></tr></table>

<p>
There is a menu associated with this file name box above the source, and
the mousehole and cursor also indicate that the right
mouse button invokes a menu over the region The menu has options
to edit the source, show used and assumed file paths, rematch and reload the
file, and to show file dates.
The latter is useful for an explanation
of why <I>ups</I> may be showing reverse video for a file.
In the bottom output window,
it list the source file date, the associated shared library date if applicable,
and the target file date.
The menu is a convenient way to get information
about a file without having to find the file in the source file list.
For breakpoints, when the source is displayed, the menu provides a quick way to
get at full file names and dates.
</P>

<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->

<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<a name="EDITABLE FIELDS"><H3>EDITABLE FIELDS</H3></a>
</td></tr></table>

<p>
All editable fields in
<I>ups</I> work in the same way.
To start editing you click the middle mouse button over the editable text.
A black
<I>marker bar</I> appears - characters that you type appear to
the left of this marker bar.
You can reposition the marker bar by clicking in the new position
with the middle mouse button, or by using one of the cursor movement
key sequences described below.

<p>
Clicking the left or right button confirms the edit.
Clicking the middle mouse button outside the editable text area
also confirms the edit.
In both cases the mouse click is then interpreted as normal - this
means that to confirm an edit you can simply move on to another activity.
The final way to confirm an edit is to type ESC (the escape key)
or click the left mouse button on the Enter Button (the small region to
the right of the typing line with the "<<" image).

<p>
To paste the current window system cut buffer, use Control-Y or click
the middle mouse button on the Enter Button.

<p>
When you try to confirm an edit
<I>ups</I> checks that the new field value is reasonable.
If not you get an error message and you are left in the edit.
An immediate second attempt to quit abandons the edit and restores the
original field value.

<p>
<I>Ups</I> recognises a subset of the GNU <i>emacs(1)</i> key bindings when editing fields.
In the current version there is no way to customise these key
bindings.
This will be fixed in a future release.

<p>
You can use most of the common <i>emacs(1)</i> key mappings when editing text
(<i>e.g.</i> in the typing line, when adding breakpoints <i>etc.</i>).
Here is a list of the supported mappings
(<TT>C-x</TT> means Control-X,
 <TT>M-x</TT> means ALT-X,
 <TT>UP</TT>, <TT>DOWN</TT>, <TT>LEFT</TT> and <TT>RIGHT</TT> are the arrow keys,
 <TT>SPC</TT> is the space bar and
 <TT>DEL</TT> is the delete key) :

<p>
<div align=center><table width = 90%>

    <TR valign=top><TD width=20%>
    <TT>C-a</tt> 
    </TD><TD>
    Move to start of line
    </TD></TR>

    <TR valign=top><TD width=20%>
    <TT>C-e</tt> 
    </TD><TD>
    Move to end of line
    </TD></TR>

    <TR valign=top><TD width=20%>
    <TT>M-m</tt> 
    </TD><TD>
    Move to first non-whitespace character
    </TD></TR>

    <TR valign=top><TD width=20%>
    <TT>M-@, M-SPC</tt> 
    </TD><TD>
    Set mark
    </TD></TR>

    <TR valign=top><TD width=20%>
    <TT>C-w</tt> 
    </TD><TD>
    Delete text between mark and point
    </TD></TR>

    <TR valign=top><TD width=20%>
    <TT>C-p, UP</tt> 
    </TD><TD>
    Move up a line, if possible, otherwise retrieve the next
    previous item in the history buffer
    </TD></TR>

    <TR valign=top><TD width=20%>
    <TT>C-n, DOWN</tt> 
    </TD><TD>
    Move down a line, if possible, otherwise retrieve the next
    later item in the history buffer
    </TD></TR>

    <TR valign=top><TD width=20%>
    <TT>C-b, LEFT</tt> 
    </TD><TD>
    Move backwards one character
    </TD></TR>

    <TR valign=top><TD width=20%>
    <TT>C-f, RIGHT</tt> 
    </TD><TD>
    Move forward one character
    </TD></TR>

    <TR valign=top><TD width=20%>
    <TT>M-b</tt> 
    </TD><TD>
    Move backwards one word
    </TD></TR>

    <TR valign=top><TD width=20%>
    <TT>M-f</tt> 
    </TD><TD>
    Move forward one word
    </TD></TR>

    <TR valign=top><TD width=20%>
    <TT>C-j, C-m</tt> 
    </TD><TD>
    In an editable field, finish the edit.
    In the source window, start a new line.
    </TD></TR>

    <TR valign=top><TD width=20%>
    <TT>ESC</tt> 
    </TD><TD>
    Finish edit, in both editable fields and the source window.
    </TD></TR>

    <TR valign=top><TD width=20%>
    <TT>C-c</tt> 
    </TD><TD>
    Cancel edit (not an emacs binding).
    </TD></TR>

    <TR valign=top><TD width=20%>
    <TT>C-k</tt> 
    </TD><TD>
    Delete to end of line
    </TD></TR>

    <TR valign=top><TD width=20%>
    <TT>C-u</tt> 
    </TD><TD>
    Delete to start of line (not an emacsbinding )
    </TD></TR>

    <TR valign=top><TD width=20%>
    <TT>C-d</tt> 
    </TD><TD>
    Delete character under cursor
    </TD></TR>

    <TR valign=top><TD width=20%>
    <TT>M-d</tt> 
    </TD><TD>
    Delete word starting at cursor
    </TD></TR>

    <TR valign=top><TD width=20%>
    <TT>DEL</tt> 
    </TD><TD>
    Delete character before cursor
    </TD></TR>

    <TR valign=top><TD width=20%>
    <TT>M-DEL</tt> 
    </TD><TD>
    Delete word before cursor
    </TD></TR>

    <TR valign=top><TD width=20%>
    <TT>C-y</tt> 
    </TD><TD>
    Paste X selection
    </TD></TR>

    <TR valign=top><TD width=20%>
    <TT>M-&gt;</tt> 
    </TD><TD>
    Move to end of buffer
    </TD></TR>

    <TR valign=top><TD width=20%>
    <TT>M-&lt;</tt> 
    </TD><TD>
    Move to start of buffer
    </TD></TR>

</table></div>
</p>

<p>
If you run
<I>ups</I> from a terminal (or a terminal emulator like
<I>xterm</I>) it tries to discover what keys you are using for delete and line erase.
If this fails it takes both <tt>^H</tt> (backspace) and <tt>DEL</tt> to mean delete, and <tt>^U</tt>
to mean line erase.
</P>

<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->

<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<a name="EDIT HISTORY"><H3>EDIT HISTORY</H3></a>
</td></tr></table>

<p>
Most of the editable fields in
<I>ups</I> have their own history of recently typed commands.
For example
there is a history of typing line commands, a history of
breakpoint code entered, and a history of variable values changed.

<p>
Pressing the Left mouse button on the History Button, the small region
to the right of the typing line with the triangular image, pops up
a menu of recently entered data for that field.

<p>
When editing most single line fields, a Control-P, or up arrow moves the history pointer back
one entry and replaces the current text with the previous entry.
Typing
a Control-N, or down arrow, moves the history pointer forward one entry.

<p>
Edit histories are saved between sessions of
<I>ups</I> in <tt>ups-state/editHistory</tt>, if you use the ups-state feature, or in
the file <tt>~/.upsEditHistory</tt> if not.
</P>

<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->

<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<a name="CUT AND PASTE"><H3>CUT AND PASTE</H3></a>
</td></tr></table>

<p>
You can select text with highlighting by pressing
the left mouse button and dragging.
Releasing the
left mouse button sets the X selection.

<p>
You can paste text into an edit with Control-Y or by clicking the
middle mouse button on the Enter Button (the small region to the right
of the typing line with the "<<" image).

<p>
Another useful trick is to define paste strings by using control characters
in a custom menu: <i>e.g.</i> define
<blockquote>
<pre>
setenv UPS_F1_STR "^e^u^y"
setenv UPS_F2_STR "^y"
</pre>
</blockquote>
then the right mouse button  will invoke a menu: the first
item clears the current text
no matter where the text cursor is, and does a paste; the second
just does a paste at the current location.
See the section
<a href="#ENVIRONMENT VARIABLES AFFECTING UPS"><small>ENVIRONMENT VARIABLES AFFECTING UPS</small></a>
for details on custom menus.

<p>
In the source window there are some extra shortcuts :

<p>
<ul>
<li>
    Pressing and releasing the left mouse button (without
    dragging) adds a variable name to the display as in
    previous versions of <i>ups</i>.
    Only if you move the mouse
    to a different character with the left button down do
    you get a plain X selection.
<p>
<li>
    Doing a press-left-and-drag selection with the SHIFT
    key pressed automatically pastes the selected text as
    an expression into the appropriate place in the stack
    trace.
    It is equivalent to selecting some text,
    selecting <b>add expr</b> for the appropriate entry in the
    stack trace, pressing ^Y to paste the text and
    hitting RETURN.
<p>
<li>
    If you hold the shift key down, the press and release
    the left mouse button without moving the mouse, ups
    adds the expression under the mouse to the display
    area.
    It makes a reasonable attempt to select what
    to display.
    Try it out to see what I mean.
</ul>
See
<a href="#PASTING EXPRESSIONS FROM THE SOURCE WINDOW"><small>PASTING EXPRESSIONS FROM THE SOURCE WINDOW</small></a>
in the manual page for more information.

<p>
In the display window, the left button
selects objects for operations, and one can pan vertically to select
groups of objects.
Selecting objects for some operation is
distinct from making an X text selection.
However, while the button is down, if the horizontal
distance from the original click exceeds a certain value, the window
shifts from selecting objects to making an text selection.
So one can easily just pan right to select a string for instance.
The pixel value is
30 by defaults, but can be overridden with an X resource.
See
<a href="#X RESOURCES"><small>X RESOURCES</small></a>
for details.

<p>
</P>

<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->

<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<a name="EDITING IN THE OUTPUT WINDOW"><H3>EDITING IN THE OUTPUT WINDOW</H3></a>
</td></tr></table>

<p>
You can edit in the output window (the window where
<tt>$printf</tt> output goes.
Click with the middle mouse button to display a cursor.
You can then append or delete text.
This is useful for tidying up output to make it clearer, or for
deleting uninteresting stuff.

<p>
You can also dump objects (like the stack trace) to the
output window (the <b>Window</b> menu item to the left of <b>Quit</b>),
and save or restore the output window contents from/to files
(<b>Load</b> and <b>Save</b> in the output window menu).
</P>

<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->

<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<a name="LISTING MATCHING SYMBOLS FOR BREAKPOINTS"><H3>LISTING MATCHING SYMBOLS FOR BREAKPOINTS</H3></a>
</td></tr></table>

<p>
Pressing Shift-ESC, or Shift-RETURN when setting a breakpoint lists matching
functions in the output window.
So <tt>*</tt> matches all function names, and <tt>file.c:*</tt> matches all
function names for <tt>file.c</tt>.
ESC states how many matching functions there are,
while holding the Shift key down lists them in the output window.
To list all
functions in a program (and there may be many thousands) enter <tt>*</tt> then
Shift-ESC.

<p>
The full path names of source files are given when listing symbols.

<p>
Stripped libraries contain
no symbol information or file names, so it is not possible to use
the <tt>file_name:function_name</tt>
syntax to specify a unique breakpoint via the <tt>Breakpoint</tt> header.
For such cases, <I>ups</I> accepts a shared library
name in conjunction with the function name.
The syntax is
<blockquote>
<tt>shared_lib_name:function_name</tt>
</blockquote>
This allows breakpoints to be set in specific shared libraries when there are
name conflicts.
The width of the breakpoint text has been doubled to allow
for longer breakpoint specifications.
</P>

<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->

<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<a name="EXAMINING THE TARGETS STATE"><H3>EXAMINING THE TARGET&acute;S STATE</H3></a>
</td></tr></table>

<p>
When the target is stopped at a breakpoint or when
<I>ups</I> has been started with a core file, the target&acute;s state is show in the
form of a <I>stack trace</I> in the display area.
This consists of a line for each active function giving the
name of the function, the source line number of the line that
was being executed, and the name of the source file containing the function.

<p>
The stack trace appears under the
<B>Functions</B>
object in the display area.
As an example, consider the following stack trace:
<PRE>
Functions
  main           main.c:42
  docmd          commands.c:84
  getline        io.c:21
</PRE>
</p>

<p>
In this example, execution in function <tt>main()</tt> reached line 42, at which
point <tt>main()</tt> called <tt>docmd()</tt>.
In turn, <tt>docmd()</tt> at line 84 called <tt>getline()</tt>,
which is stopped at line 21 (which is yet to be executed).

<p>
When the target stops, the source of the innermost function is displayed,
with the line that is just about to be executed highlighted (displayed
in reverse video).
To look at the source of other functions in the stack trace :

<ul>
<li>
    Click the left mouse button over a line in the stack trace.
    The line is highlighted, and a menu appears near the top of the
    window with the captions
    <B>Expand</B>,
    <B>Collapse</B>,
    <B>Add expr</B>,
    <B>Source</B>,
    and
    <B>Path</B>.
<p>
<li>
    Click on
    <B>Source</B>
    in the menu.
    The source corresponding to the selected line in the stack trace
    is shown, with the line that is currently executing highlighted.
</ul>
In this way you can see exactly where the target is stopped at any
level in the stack.
</P>

<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->


<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<a name="EXAMINING VARIABLE VALUES"><H3>EXAMINING VARIABLE VALUES</H3></a>
</td></tr></table>

<p>
There are several ways to find the values of variables.
The simplest and most often used is simply to click with the
left mouse button on the name of a variable in the source region.
A line is added to the display area which looks something like:
<blockquote>
<PRE>
int &lt;varname&gt;     73
</PRE>
</blockquote>

<p>
In this example, an integer variable called <I>varname</I> with a current value
of 73 is shown.
The meaning of the angle brackets around the name is
explained later - ignore them for now.

<p>
If the variable is local to a function, it is added just below the
line in the stack trace for that function.
If the variable is global, an entry for the source file of the variable
is added below the
<B>Source files</B>
object in the display area and
the variable is displayed below that.
In rare cases
<I>ups</I> does not know the type of the variable, in
which case it is assumed to be an integer and displayed under the
<B>Untyped variables</B>
object.

<p>
Once the variable is added to the display, it remains there until
its function returns (for a local variable) or you explicitly
delete it (see later for how to do this).
This means that you can watch the value change as you control the
execution of the target.

<p>
As well as selecting individual variables to be shown, you can add all
the local variables of an active function to the display.
Select the function in the stack trace whose variables you wish to see,
and select
<B>Expand</B>
from the menu produced.
This will produce a popup menu with the options
<B>Like before</B>
and
<B>Completely.</B>
The default option is
<B>Like before</B>
- it means to make the display look like it did last time you looked
at the local variables for this function.
If there is no <i>last time</i>, all the local variables are displayed.
The second
<B>Expand</B>
option
(<B>Completely</B>)
always adds all the function&acute;s local variables to the display.

<p>
To remove all the local variables select
<B>Collapse</B>.
You can subsequently put them back as they were using
<B>Expand</B>,
<B>Like before</B>.
If you have saved state enabled, you can do this even after exiting
<I>ups</I> and starting it again.
See the
<a href="#SAVING STATE"><small>SAVING STATE</small></a>
section for details.

<p>
When you use
<B>Expand</B>
to add all the local variables of a function,
you may see some lines like this:
<blockquote>
<PRE>
lines 84..93
</PRE>
</blockquote>

<p>
These lines are added for variables declared within inner blocks of a
function.
In this example, there is an inner block starting at line 84 and ending
at line 93 which contains local variable declarations (the line numbers
are sometimes inaccurate because of bad information supplied by some compilers).
If you click the left mouse button over one of these entries, a menu
with the options
<B>Expand</B>,
<B>Collapse</B>,
<B>Add Expr</B>
<B>Source</B>,
and
<B>Path</B>,
is
produced.
Selecting
<B>Expand</B>
adds to the display all variables declared in the block.
<B>Collapse</B>
removes them again, and
<B>Source</B>
makes the first line
of the block visible in the source region.
Selecting <B>Path</B> brings
up a sub menu with <B>Used</B>, <B>Assumed</B>, <B>Rematch</B>, <B>Reload</B> and <B>Dates</B>
items.
The <B>Used</B> item shows 
what file is actually being displayed in the source window.
The <B>Assumed</B>
item displays
the assumed path name of the selected file as suggested by the target
binary.
If the file could not be found under the <B>Assumed</B> name,
the <B>Used</B> name will be the first good match in the source path list.
For C code, there is normally no problem in finding the source and hence
the  <B>Used</B> and <B>Assumed</B> paths will be the same.
For  Centerline C++ code,
the two are usually different.
<I>Ups</I> uses symbol table function
line number information to find the most likely match.
This also allows
different files of the same name to be located correctly.

<p>
This feature removes the need to constantly rearrange the <B>Use</B> paths in
the <I>ups</I> init file to accommodate debugging different targets.
<I>Ups</I> outputs
a message for C++ files indicating what file was matched.

<p>
When no symbols are available
for a function, both items print the library name for that function.

<p>
If for some reason the match process described above gets the wrong file,
it is possible to find the next match in the search path list.
To
replace the file with the next match, select the <B>Rematch</B> item in the
<B>Path</B> menu.

<p>
The <B>Reload</B> item will
reload the currently selected file.
A situation where this may be useful
is, when in the middle of a debug session, it becomes apparent that
the debugger is using version of a file that differs from the
build version of the file.
If the current version is newer than the object
code, or the target, the file will appear in reverse video as a warning.
To correct such a problem, restore the file, and reload.
This will reload the text and also retest the file dates and remove the
reverse video if appropriate.

<p>
The <B>Dates</B> item shows the full names and dates of the source
file, shared library if used, and target binary.

<p>
See the later section
<a href="#CONTROLLING THE DISPLAY OF VARIABLES"><small>CONTROLLING THE DISPLAY OF VARIABLES</small></a>
for information on (among other things) how to change the format of a
displayed variable, indirect through pointers, expand structures and unions
and step through the elements of an array.
</P>

<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->


<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<a name="ACCELERATORS IN THE DISPLAY AREA"><H3>ACCELERATORS IN THE DISPLAY AREA</H3></a>
</td></tr></table>

<p>
A SHIFT-left click or double left click does the most commonly used actions
for the object listed below :

<blockquote>
<dl>
    <dt><B>env header</B>
	<dd>Toggle between expanding and compressing the environment display.
    <dt><B>signal header</B>
	<dd>Toggle between expanding and compressing the signal display.
    <dt><B>source header</B>
	<dd>Toggle between expanding and compressing all source files.
	Files are expanded to <tt>like before state</tt>.
	If some files have variables or expressions displayed,
	such files will remain visible when the source file list is compressed.
	Use the menu item "completely" to remove all source files.
    <dt><B>source files</B>
	<dd>Toggle between expanding and compressing all the global variables of the file
    <dt><B>file add expr</B>
	<dd>See the actions under <b>variable</b>.
    <dt><B>function</B>
	<dd>Toggle between expanding and compressing all the outermost local
	variables.  Variables are expanded to <tt>like before state</tt>.
    <dt><B>function block</B>
	<dd>Toggle between expanding and compressing all the local variables of the block
    <dt><B>func add expr</B>
	<dd>See the actions under <b>variable</b>.
    <dt><B>variable</B>
	<dd>If the variable is a struct or union, or pointer to  a struct
	or union, toggle between expanding and compressing 
	the current level of the variable.  If the variable is a pointer
	to data of integer type, dereference the pointer one level.  If the
	variable is of integer type, or fully dereferenced pointer to a
	such a variable, toggle between unsigned hex and signed decimal
	formats.
    <dt><B>bpt header</B>
	<dd>By default, toggle the global breakpoint enable flag.
	The <tt>BreakPointHeaderAcceleratorAction</tt>
	X resource may be set to request that <i>ups</i> prompt for a
	new breakpoint instead.
    <dt><B>breakpoint</B>
	<dd>By default, toggle the current breakpoint between the active and
	inactive states.
	The
	<tt>BreakPointAcceleratorAction</tt>
	X resource may be set to request that the breakpoint be removed instead.
	Double clicking ( but not SHIFT-clicking) on the breakpoint in the source
	window selects has the same effect of toggling or removing breakpoint
	according to the 
	<tt>BreakPointAcceleratorAction</tt>
	X resource.
</dl>
</blockquote>
</p>

<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->


<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<a name="SOURCE FILES MENU"><H3>SOURCE FILES MENU</H3></a>
</td></tr></table>

<p>
There is a menu for compressing the source file list.
It has options
of <b>first level</b> and <b>completely</b>.
The SHIFT-left accelerator on the
source file header is equivalent to <b>first level</b>.
When globals are
displayed in <I>ups</I>, they appear under the source file name.
The <b>first level</b> item only removes files that do not have any globals
or expressions displayed.
This cleans up the display, just leaving items
of interest.
The <b>completely</b> item removes all file names and globals from the display.

<p>
If state has been saved from a prior usage of <i>ups</i> on the same target,
by creating a <tt>ups-state</tt> directory, the next invocation of the debugger
allows you to restore the globals shown before.
After the target is running,
simply expand the source file list to show all files and the chosen
globals, then compress the list to the first level to leave just the
globals.
</P>

<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->

<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<a name="BREAKPOINT MENUS"><H3>BREAKPOINT MENUS</H3></a>
</td></tr></table>

<p>
By selecting a breakpoint, the
<B>Activate</B>
and
<B>Inactivate</B>,
captions control whether the breakpoint is either active or inactive.
Active code is
executed normally, whereas inactive code is ignored.
The activation state
is set by the two captions labeled <B>Activate</B> and <B>Inactivate</B> that
appear after selecting the breakpoint object.
The current state appears to
the right of the breakpoint line number.
The
<B>Execute</B>
caption can be used to execute breakpoint code
whenever the target context allows it.
The most common use for this
is to repeatedly call a function, such as the Purify API functions
<tt>purify_describe()</tt> or <tt>purify_all_leaks()</tt> without having to enter the
call at every line in the source where it may be required.   

<p>
By selecting
the <B>Breakpoints</B>
header object, the captions labeled
<B>Enable</B> and <B>Disable</B>
allow global control of processing of breakpoints.
When globally enabled, all breakpoint code is examined, and if the breakpoint
is active, the code is executed.
Conversely, when breakpoint code is
globally disabled, no breakpoint code is executed, regardless of
its activation state.
The current enabled state is implicitly shown
by the shaded caption - so after pressing <B>Disable</B>, that
caption is shaded and the <B>Enable</B> caption becomes normal.

<p>
When globally disabled or individually inactivated,
the breakpoint code will still
exist in the source, but the code will be ignored until re-enabled.
The target will run at full speed for such breakpoints.

<p>
When typing in a breakpoint, pressing ESC does partial name completion
whenever possible.
So if a program has just two routines, <tt>process_key()</tt>
and <tt>process_cmd()</tt>, typing <tt>p</tt> then ESC will expand the line to <tt>process_</tt>
and in the third line will be a message like
<tt>process_</tt> matches <tt>process_key</tt> and <tt>process_cmd</tt>.
Then typing <tt>k</tt> then ESC will complete the line to <tt>process_key</tt>
See the
<a href="#LISTING MATCHING SYMBOLS FOR BREAKPOINTS"><small>LISTING MATCHING SYMBOLS FOR BREAKPOINTS</small></a>
section for details on listing the matches.
</P>

<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->

<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<a name="SPECIAL HANDLING FOR SIGSEGV AND SIGBUS"><H3>SPECIAL HANDLING FOR SIGSEGV AND SIGBUS</H3></a>
</td></tr></table>

<p>
Some programs have exception handlers that allow the program to continue to run
despite receiving <tt>SIGKILL</tt>, <tt>SIGSEGV</tt> or <tt>SIGBUS</tt> signals.
If <tt>SIGSEGV</tt> or <tt>SIGBUS</tt> are
changed from the default of <tt>Stop - ignore signal on continue</tt> to
<tt>Stop - accept signal on continue</tt>, <I>ups</I> will stop on the exception,
but allow the target to continue running upon pressing
<B>Cont</B>,
<B>Next</B>,
or
<B>Step</B>.

<p>
<tt>SIGSEGV</tt> or <tt>SIGBUS</tt> signals that intercepted by third party software such
as ObjectStore can be handled by setting the signal to <B>accept and continue</B>.
Do not use <B>ignore</B> as then the target never gets the signal and it will
appear to hang.
However, when set to <B>accept and continue</B>, the target
can crash on bad code, but <I>ups</I> will not catch it.
For such cases, set
a breakpoint in the a target&acute;s signal handler (if it has one), or change
<tt>accept</tt> to <tt>stop</tt>.
</P>

<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->

<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<a name="CONTROLLING TARGET EXECUTION"><H3>CONTROLLING TARGET EXECUTION</H3></a>
</td></tr></table>

<p>
Once you have the target stopped at a breakpoint there are several
ways of controlling its execution.
Most of these are invoked from the <I>target menu</I> - the permanent
menu just below the display area.

<p>
The usual way of debugging is to set a breakpoint in the function which
you think is misbehaving and then step through its code one line at a time.
The
<a href="#GETTING STARTED"><small>GETTING STARTED</small></a>
section above explains how to set breakpoints
and start the target running.
To step over a line of source, select
<B>Next</B>
from the target menu.
The code on the highlighted line is executed, and the highlighting
moves on to the next line to be executed.

<p>
The values of variables in the display area are updated every time the
target stops, so you can watch values change as you step through the
code.
On colour displays variables are shown in a different colour if their
values have changed since the last time the target stopped.

<p>
If the line to be executed calls a function,
<B>Step</B>
takes you to the first line of the called function,
and stepping continues in the function.
The step action may take some time occasionally; however the
<B>Stop</B>
command can be used to break out such a situation.
If you don&acute;t want to step through the code of called functions in this
way, use the
<B>Next</B>
command.
This behaves like
<B>Step</B>,
except that it never steps into called functions.

<p>
Both
<B>Next</B>
and
<B>Step</B>
work with respect to the currently displayed source.
If you click on a function in the stack trace and select
<B>Source</B>
to display its source, a subsequent
<B>Next</B>
or
<B>Step</B>
moves to the next line of the displayed source.
This makes it easy to get out of a function that you have stepped into
by accident and don&acute;t wish to step all the way through.
Use the
<B>Source</B>
command to display the source of the calling function, then use
<B>Next</B>
or
<B>Step</B>.

<p>
The
<B>Cont</B>
command in the target menu offers a third way to
control the target - this command runs the target until it
hits another breakpoint, gets a signal, or exits.

<p>
See the section
<a href="#THE SOURCE REGION"><small>THE SOURCE REGION</small></a>
for details about the
<B>Attach</B>
and
<B>Detach</B>
buttons.

<p>
Finally, you can <i>drag</i> execution in the target to a line in the
source file.
Move the mouse cursor over the line you wish to get to, and press
and hold down the right mouse button.
A popup menu appears, with the captions
<B>Add breakpoint</B>
<B>Execute to here</B>.
<B>Jump to here</B>.
and
<B>Edit source</B>.
Drag the mouse down so that the
<B>Execute to here</B>
caption is highlighted, and release the button.
The effect of this is to set a temporary breakpoint at the line,
temporarily disable all other breakpoints, and then continue the
target.
You can use this command to move past uninteresting bits of code
without having to set up and remove breakpoints.

<p>
The second command on the popup menu,
<B>Add breakpoint</B>,
adds a breakpoint at the line of source you pointed at.
Unfortunately, to set a breakpoint at (or execute to) a single statement that
extends over several text lines, you must point at the last
text line.
This is due to limitations in the symbol table information put out
by the compilers.
The 
</b>Jump to here</b>
command causes the target execution to jump to the current line
without executing any intervening code.  Use this with caution as it
is possible to jump to a bad context where the data is bad or where there
is no valid call stack.  The safest usage is to jump over lines
within a function.  It can also be used to jump back within a function.
The
<B>Edit source</B>
command spawns an editor (typically either emacs or vi),
and set the cursor at the current location in the file.
The editor
used is controlled by the <tt>EDITOR</tt> environment variable.

<p>
You can stop the target running at any time by clicking on
<B>Stop</B>
in the target control menu.
The target will then stop wherever it is currently executing as if it
had hit a breakpoint.
In addition, if a symbol search puts the debugger
in a long traversal of stack functions or files, the
<B>stop</B>
command will break it out of the search.
The command is queued, and will
be honored after completing the scan of the current function or file.
In addition, the
<B>stop</B>
command will break out of a
<B>step</B>
command that is taking a long time.

<p>
The
<B>Kill</B>
command kills off the current instance target process.
You can then use
<B>Start</B>
or
<B>Execute to here</B>
to start the target again.
Quitting
<I>ups</I> also kills the target process (unless you attached
<I>ups</I> to a running process, in which case
<I>ups</I> detaches from the process and leaves it to continue unmolested).
</P>

<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->

<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<a name="THE TYPING LINE MENUS"><H3>THE TYPING LINE MENUS</H3></a>
</td></tr></table>

<p>
The caption labeled <B>Windows</B>, just to the left of the <B>Quit</B>
caption, provides a number of options loosely related to coordinating
the various <i>ups</i> windows.
The <B>Snapshot Selected Objects</B> item dumps objects (like the stack trace)
to the output window.
The <B>Snapshot All Objects</B> item dumps the complete display to the output
window.

The <B>Message Logging</B> item toggles on or off the copying of all subsequent
messages printed to the
message line to the bottom window.
As well as providing a log of messages,
this facility allows the text of messages to be selected for pasting.
This allows a path that has been displayed with the path caption to
be pasted when setting a breakpoint in a function name that is not unique.

<p>
The four items <b>No Raise On Break</b>, <b>Raise On Break</b>,
<b>Raise On Break/Lower On Run</b> and <b>Raise On Break/Iconify On Run</b>
select how
<i>ups</i>
manages its window(s) when the target process goes in or out of run.
The default action is <b>No Raise On Break</b>, that is, no special action
is taken.
If <b>Raise On Break</b> is selected,
<i>ups</i>
will automatically raise its main window to the foreground when the debugged
application stops.
If <b>Raise On Break/Lower On Run</b> is selected, then in addition to
raising the main window on a break,
<i>ups</i>
will lower the main window to the bottom of the window
stack, after a brief delay, when the process goes into run.
If <b>Raise On Break/Iconify On Run</b> is selected, then in addition to
raising the main window on a break,
<i>ups</i>
will iconify the all windows, after a brief delay, when the process goes
into run.

<p>
In split screen modes, these options raise or lower the window containing
the source display and <b>Start</b>/<b>Next</b>/<b>Step</b> buttons.

<p>
The initial state of these options may be set using the
<i><tt>WantRaiseOnBreak</tt></i>
family of X Resources
(see the section
<a href="#X RESOURCES"><small>X RESOURCES</small></a>
below), or by the <tt>-raise_on_break</tt>, <tt>-lower_on_run</tt>,
and <tt>-iconify_on_run</tt> command line options.

<p>
The button labeled <B>Search</B> to the left of the <B>Windows</B> button
is used to search for regular expressions
(using the same syntax as <I>grep(1)</I> patterns) in the display window.
First type in the pattern to be searched for (typed characters appear
in the typing line at the top of the window on the left) then
press and hold down the left mouse button over the
<B>Search</B>
caption.
A popup menu appears with the options
<B>Backwards</B>
and
<B>Forwards</B>.
Move the mouse over the one you want and release the button.
If the pattern is found, the matching text is made visible in the
display region and highlighted.

<p>
The button labeled <B>Help</B> to the left of the <B>Search</B> button
provides simple textual help information on a variety of topics.
Output is placed in the bottom output window.
By default, the text is appended
to the bottom of the window, with the scrollbar positioned so that the
topic begins at the top of the window.
The last item in the <B>Help</B>
menu allows the window to be cleared before a new help topic is printed out.
</P>

<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->

<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<a name="TARGET COMMAND LINE ARGUMENTS"><H3>TARGET COMMAND LINE ARGUMENTS</H3></a>
</td></tr></table>

<p>
The second line of the display area shows the command line arguments that
will be given to the target when it is next started.
The arguments shown include the zero&acute;th argument which is initially set to the name
of the target.

<p>
You can specify an initial set of arguments for the target with the
<B>-a</B> option when you start
<I>ups</I>.
If you don&acute;t give the
<B>-a</B> option and you are debugging from a core file,
<I>ups</I> attempts to extract the command line arguments from the core file.
Otherwise the command line contains no arguments other than the name of the
target.

<p>
<I>Ups</I> parses the command line in a similar way to the shell.
It supports Bourne shell type redirection (&gt;, &gt;&gt;, &lt;, &gt;&amp;dig, <i>etc.</i>) as
well as the <I>csh</I> forms &gt;&amp; and &gt;&gt;&amp;.
<I>Ups</I> also understands most <I>csh</I>
metacharacters - globbing with <tt>*</tt>, <tt>?</tt> and <tt>[xyz]</tt>, the <tt>~</tt>, <tt>~user</tt> and
<tt>{a,b,c}</tt> shorthands, and quoting with single or double quotes and backslash.
The current version of
<I>ups</I> does not support
<tt>$</tt><i>var</I> type shell variable substitution.

<p>
You can edit the command line at any time to change the command line arguments
(although the changes will only take effect when you next start the target).

<p>
The command name shown is just the zero&acute;th argument and can be edited just
like the other arguments.
This is useful with programs which use the zero&acute;th argument as a sort of
hidden flag.
Changing the command name only affects the arguments given to the target -
it does not change which program is being debugged.
</P>

<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->

<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<a name="CONTROLLING THE DISPLAY OF VARIABLES"><H3>CONTROLLING THE DISPLAY OF VARIABLES</H3></a>
</td></tr></table>

<p>
When you add a variable to the display (see
<a href="#EXAMINING VARIABLE VALUES"><small>EXAMINING VARIABLE VALUES</small></a>
above)
it is displayed in a default format.
If you click the left button over the line for the variable, a menu
appears in the top part of the window.
You can use this menu to set the display format for the variable (<B>Format</B>),
to change the level of indirection for pointers
(<B>*</B> and <B>&amp;</B>),
to expand all base classes and show vector tables for a class
(<B>::</B>),
to show all the members of structures and unions
(<B>Expand</B>
and
<B>Collapse</B>),
to choose the format variables are displayed in
<B>Format</B>,
to duplicate or delete entries for variables
(<B>Dup</B> and <B>Del</B>)
and to control whether typedefs are used in displayed variables
(<B>Decl</B>).

<h4>Pointers</h4>

<p>
The default for a pointer variable is simply to show the pointer value
in hex.
To take a common example, if you add a variable of type
<i>pointer to pointer to char</i>
called
<TT>argv</TT>
to the display, you will get a line like :
<blockquote>
<PRE>
char **&lt;argv&gt;     0x7fffe184
</PRE>
</blockquote>

<p>
The angle brackets separate the type from the value.
In this example, what is shown is the value of argv, which is of type
<TT>char **</TT>.

<p>
If you now click with the left mouse button on this line, and select
<B>*</B>
(the leftmost caption) in the variables menu, the format
of the line changes to something like :
<blockquote>
<PRE>
char *&lt;argv{0}&gt;   0x7fffe1d0
</PRE>
</blockquote>

<p>
This says that what is shown is the value of
<TT>argv[0]</TT>,
which is of type
<TT>char *</TT>.
The braces (<tt>{</tt> and <tt>}</tt>) are used to distinguish a dereferenced pointer
from a true array.

<p>
A second click on the
<tt><B>*</B></tt>
menu option changes the line to:
<blockquote>
<PRE>
char &lt;argv{0}{0}&gt; "foo"
</PRE>
</blockquote>
</TT><!-- .in -4m -->

<p>
This is a special case in
<I>ups</I> - variables of type
<TT>char</TT>
are displayed as strings if they are indirected pointers or members of arrays.

<p>
The
<B>&amp;</B>
menu option is the opposite of
<B>*</B>
- it drops
one level of indirection.
You can only use this on indirected pointers.
Use an expression if you want to see the address of a variable (see
<a href="#EXPRESSIONS IN THE DISPLAY AREA"><small>EXPRESSIONS IN THE DISPLAY AREA</small></a>
below).

<h4>Arrays</h4>

<p>
Arrays are initially displayed with all subscripts zero.
You can edit the subscript to another value by clicking on it
with the middle mouse button.
A marker bar appears, and you can use the delete key to delete the
old subscript and type a new one.
When you hit ESC, the value of the new array element is shown.

<p>
Often you wish to quickly scan through all the elements of an array.
You can do this using either the arrow key or the <tt>&gt;</tt> and <tt>&lt;</tt> keys.
When editing an array subscript, the <tt>&gt;</tt> key adds one to the
subscript value and displays the new element.
Similarly, the <tt>&lt;</tt> key subtracts one from the subscript value.
Using these keys you can rapidly scan up or down an array.

<p>
<I>Emacs</I> users can use <tt>C-P</tt> (Control-P)
and <tt>C-N</tt> (Control-N) as synonyms for <tt>&lt;</tt>&nbsp;and&nbsp;<tt>&gt;</tt>.
<I>Vi</I> users can use <tt>k</tt>&nbsp;and&nbsp;<tt>j</tt> similarly.

<p>
The arrow (or whatever) keys actually act on the digit to the left of
the cursor, so by moving the cursor left you can step by tens,
hundreds <i>etc.</i>.

<h4>Structures</h4>

<p>
Note: in this section <i>structures</i> also include unions: they are simply
treated as structures with all members having an offset of zero.

<p>
Variables that are structures or pointers to structures are initially
displayed with just the address in hex.
You can use the
<B>Expand</B>
command in the variables menu to add
all the members of a structure to the display.
The structure members are indented to make it clear which structure
they belong to.
Clicking on
<b>Expand</b>
will produce a popup menu with the options
<b>Expand Structure</b>
and
<b>Expand Static Variables</b>.
Selecting 
<b>Expand Structure</b>
will display all the non-static members members of the structure
except vector tables. ( See the section
<a href="#EXAMINING BASE CLASSES AND VECTOR TABLES"><small>EXAMINING BASE CLASSES AND VECTOR TABLES</small></a>
below for vector tables.)
If the selected item is a member of a class with static members, the
<b>Expand Static Variables</b>
option will show all the static members of the class.  See the section
<a href="#EXAMINING STATIC MEMBERS OF CLASSES"><small>EXAMINING STATIC MEMBERS OF CLASSES</small></a>
below.

<p>
If a structure element is itself a structure or a pointer to a structure,
it can be expanded in turn to show all its members.
In this way linked data structures can be explored.
For a more selective way of exploring a linked data structure, see
the
<a href="#EXAMINING LINKED DATA STRUCTURES"><small>EXAMINING LINKED DATA STRUCTURES</small></a>
section below.

<p>
To remove all the members of a structure from the display, use the
<B>Collapse</B>
command in the variables menu.
This has a submenu with the options
<B>First level</B>
and
<B>Completely</B>.
The first of these removes all members except expanded ones; the second
recursively collapses all expanded structures below the selected one.

<h4>Changing formats</h4>

<p>
By default integer variables are displayed in decimal
and pointer values are shown in hex.
You can change the format with the
<B>Format</B>
command in the
variables menu.
The possible formats are signed or unsigned decimal, hex, octal and binary,
as well as <b>ascii</b> and <b>string</b>.
The <b>ascii</b> format displays integers in C character notation (<i>e.g.</i>
the value 65 is displayed as <tt>a</tt>).
The <b>string</b> format is applicable to variables of type
<TT>char</TT>
that are indirected pointers or arrays - it treats the address
as the first character of a NULL terminated string.

<p>
Floating point values are shown in the conventional notation (using the
<TT>0</TT>
format).
You can use the
<B>Format</B>
command to display a hex representation of the value (it makes no difference
whether you select signed or unsigned hex from the menu).
This shows in hex the bit pattern used to represent the floating point value.

<h4>Duplicating and deleting entries</h4>

<p>
The
<B>Delete</B>
command in the variables menu deletes
all selected variables from the display area.
This is useful for tidying up the display by removing variables
that are no longer of interest.

<p>
Sometimes it is useful to have a variable displayed more than
once.
One common case is where you want to see several elements of an
array simultaneously.
The
<B>Dup</B>
command in the variables menu duplicates the
entries for all selected variables.
So to see multiple elements of an array, use
<B>Dup</B>
to
add an entry for each element you wish to see, then
edit the subscripts separately for each entry.
When duplicating a pointer variable for which the contents
of the pointer is displayed, the array index is bumped by 1, or
by 40 if a string is displayed.

<h4>Use of typedefs</h4>

<p>
If a <i>structure</i>, <i>union</i> or <i>enum</i> has a <i>typedef</i> name then
<I>ups</I> will use it in the display area.
Thus if you have the following in a function:
<blockquote>
<PRE>
typedef struct foo_s {
    int x;
    int y;
} foo_t;

foo_t *f;
</PRE>
</blockquote>
then clicking on variable
<TT>f</TT>
will add a line like:
<blockquote>
<PRE>
foo_t *&lt;f&gt        0x40ec
</PRE>
</blockquote>

<p>
to the display area.
Typedefs are not used if they hide a level of indirection or an
array, or if the typedefed type is not a struct, union or enum.

<p>
If you want to see the non-typedef type for a variable in the display
area, select the variable and press and hold down the left mouse button
over the
<B>Decl</B>
command in the variables menu.
This produces a popup menu with the captions
<B>Use typedefs</B>
and
<B>Ignore typedefs</B>.
Release the mouse over
<B>Ignore typedefs</B>
and you will be shown the non-typedefed type for all the selected variables.
</P>

<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->

<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<a name="CHANGING VARIABLE VALUES"><H3>CHANGING VARIABLE VALUES</H3></a>
</td></tr></table>

<p>
You can change the value of a displayed variable simply by editing
the displayed value (<i>i.e.</i> by clicking on it with the middle mouse
button and editing in the new value).
This works for C pointers and integral types (including <i>enum</i>s), floating
point values and strings.

<p>
You can use any of the integer display formats for the new value
(decimal, hex, octal, binary or ASCII character).
You can use enum constant names for new enum values, and function
names for function pointers.
When editing strings or characters you can use the standard C notation
for special characters
(<tt>&#92;n</TT>,
<tt>&#92;b</TT>,
<tt>&#92;007</TT>
<i>etc.</i>).

<p>
Normally
<i>ups</i>
will not let you edit extra characters into a string as this would
overwrite whatever was stored in memory just after the string.
If space is known to exist (for example if the string is stored
in an array of known size and there are unused bytes) then you can add
as many characters as will fit.
If you know you want to overwrite memory beyond the end of the string
you can force
<I>ups</I> to accept a long value by putting
<tt>&gt;&gt;</TT>
before the leading quote character of the string.

<p>
Normally a trailing NULL
(<TT>&#92;0</TT>)
is added to the edited string in the normal C way.
If you delete the trailing quote character then this is omitted.
</P>

<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->

<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<a name="EXPRESSIONS IN THE DISPLAY AREA"><H3>EXPRESSIONS IN THE DISPLAY AREA</H3></a>
</td></tr></table>

<p>
You can add C expressions as well as variables to the display area.
This is useful if you wish to see what an expression in the source
code evaluates to.
It also allows you to use casts when you know better than the source
code what the type of a given variable is.

<p>
To add an expression, select a function in the stack trace and
click on
<B>Add expr</B>
in the function menu.
A marker bar appears, ready for you to enter an expression.
When you have finished type ESC, and if the expression is legal
the value will be displayed.
If there is an error in the expression you will get an error message
and the marker bar will be repositioned at the point of the error.

<p>
In an expression you can use any variable name, structure tag or typedef
name that is in scope in the function.
If you want to add expressions using a variable in an inner block,
you will have to add the expression to the appropriate inner block.
The easiest way to get the inner block object displayed is to click
on a variable in the inner block in the source region.
Once it is displayed select the block header and click on
<B>Add expr</B>
in its menu.

<p>
You can <i>bump</i> numbers in expressions in a similar way to array
subscripts.
Hitting the down arrow (or Control-N) over a number while editing an expression
increases the digit to the left of the marker bar and displays
the new value of the expression.
Similarly the up arrow (or Control-P) decreases the digit to the left of the
marker bar and redisplays the expression value.

<p>
Expressions are reevaluated like variable values every time the target stops.
They also have the same menu associated with them as variables,
and you can have both expressions and variables in the same selection.
The <b>*</b> and <b>&amp;</b> menu commands don&acute;t work on expressions, but all the others
work as they do on variables.
This means in particular that if you add an expression whose type
is <i>pointer to struct</i>(or <i>union</i>) you can use
<B>Expand</B>
to show the structure elements.
You can also use
<B>Format</B>
to change the format used to display the expression value.

<p>
You can&acute;t call target functions or modify target data in a display
area expression (thus operators like <tt>++</tt> are illegal).
</P>

<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->

<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<a name="EXAMINING BASE CLASSES AND VECTOR TABLES"><H3>EXAMINING BASE CLASSES AND VECTOR TABLES</H3></a>
</td></tr></table>

<p>
When the object selected is a class, clicking on
<b>::</b> (double colon)
recursively adds all base classes for the object to the display, and
displays the vector table(s), showing the address symbolically when
possible.  This is useful if you want to expand a base class to
look at a member of a base class several levels deep in the class hierarchy,
without expanding everything in between.

<p>
In addition, it is usually possible to tell from the name of the
vector table which subclass of the current class the object is "really"
a member of.

<p>
A special case worth knowing about occurs when the selected object has
been deleted.  In this case, the vector table will indicate
that the object is a member of the root class for the class hierarchy,
rather than of any subclass.

<p>
For example, consider the short C++ program :
<blockquote>
<pre>
class A {
public:
                A() { cnt++;} 
   virtual      ~A() { cnt--;}
private:
   static int cnt;
};

int A::cnt;

class B : public A {
public:
          void bad();
  virtual void v() {}
};
class C : public B {
public:
  virtual void v() {}
};
void B::bad()
{
   delete this;
   v();
}
main()
{
   C* c = new C;
   c->bad();
}
</pre>
</blockquote>
If you stop at the start of <tt>B::bad()</tt>, click on <tt>this</tt> then select <b>::</b>, you
will see something like :
<blockquote>
<pre>
Functions
   main
   B::bad
     B* <this{0}>         0x12345678
       struct A <A>          0x12345678
         void *<_vtbl.>         C::__vtbl
Breakpoints
</pre>
</blockquote>
The <tt>_vtbl</tt> entry shows that <tt>this</tt> is really a C, a subclass of B.
<p>
When you single step over the delete, the display changes to
<blockquote>
<pre>
Functions
   main
   B::bad
     B* <this{0}>         0x12345678
       struct A <A>          0x12345678
         void *<_vtbl.>         A::__vtbl
Breakpoints
</pre>
</blockquote>
Since class A is a base class for B, seeing that <tt>this</tt> is really
an A in a method for class B is surely an error, and often results from
object having been been deleted.

<p>
The expansion of base classes only works for compilers that include
base class information in their symbol tables, namely for g++ and Sun SC4.
The symbolic representation of vector tables works for both of these
and also for cfront.
</p>

<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->

<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<a name="EXAMINING STATIC MEMBERS OF CLASSES"><H3>EXAMINING STATIC MEMBERS OF CLASSES</H3></a>
</td></tr></table>

<p>
Static members of classes may be examined as other global data.
In addition, depending on the compiler, they may be examined
as members of a structure are examined.

<p>
In the example in the previous section, 
the static member <tt>A::cnt</tt> may be displayed by :
<blockquote>
Typing <tt>A::cnt</tt> in the typing line.
<p>
Clicking on <tt>A::cnt</tt> anywhere in the source window.
</blockquote>
<p>
In addition, if the compiler supplies information about static
members in the symbol table (g++ and Sun SC4 do this), <tt>A::cnt</tt>
may be examined by :
<blockquote>
While in a <b>non</b>-static method for class A, click on <tt>cnt</tt> in the source window.
<p>
Select an object of type A and enter <tt>.cnt</tt> in the typing line.
<p>
Select an object of type A, press the 
<b>Expand</b>
option then select
<b>Expand Static Variables</b>
from the resulting popup menu.  This latter option displays all
static members for class A.
</blockquote>


<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->

<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<a name="PASTING EXPRESSIONS FROM THE SOURCE WINDOW"><H3>PASTING EXPRESSIONS FROM THE SOURCE WINDOW</H3></a>
</td></tr></table>

<p>
It is often useful to display the value of an expression in the source.
You could select
<B>Add expr</B>
as described in the previous section,
and cut and paste the expression from the source window.
This works, but there is a quicker way: simply select the text of the
expression in the source window while holding the shift key down (<i>i.e.</i>
press the shift key, then drag the mouse over the desired text).
When you release the mouse button, the selected text is added as an
expression in the display area.
It is OK to drag over multiple lines.

<p>
You will notice that when you first press the left mouse button (with
the shift key pressed), ups highlights some text.
This is its guess as the to expression you would like to paste.
If you are happy with this, release the mouse button without moving
the mouse, and the highlighted text will be added as an expression.
If the highlighted text is not what you want, drag the mouse to make
the selection as described before.

<p>
Pasting expressions from the source window can often fail because of
preprocessor macros which
<I>ups</I> does not understand (<i>e.g.</i>
<TT>NULL</TT>).
The correct fix for this is for
<I>ups</I> to understand
<TT>#defines</TT>,
but in the interim there is a workaround: if the file
<TT>ups-state/repltab</TT>
exists below
the current directory ups will apply the substitutions specified
there.
Here is a
<TT>repltab</TT>
file that would deal with
<TT>NULL</TT>
and
<TT>EOF</TT> :
<blockquote>
<PRE>
# Repltab for ups
NULL 0
EOF  (-1)
</PRE>
</blockquote>

<p>
Hash comments and blank lines are ignored in the normal way.
Any substitutions will be visible in the pasted expression.

<p>
<i>Ups</i> checks to see if the <tt>repltab</tt> file has been updated each
time an expression is pasted, so you don&acute;t have to restart <i>ups</i>
to it to notice changes.
</P>

<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->

<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<a name="ADDING INTERPRETED CODE"><H3>ADDING INTERPRETED CODE</H3></a>
</td></tr></table>

<p>
The
<I>ups</I> display area gives a good picture of that state of
a program at any one time.
Often though, you want a record of what happened over a series
of calls of a function.
This is one of the reasons why people still tend to put print statements in code
despite the availability of debuggers and the inconvenience
of recompiling the code.

<p>
To make it easier to add diagnostic output statements,
<I>ups</I> allows you to insert fragments of C code at any breakpoint.
The default breakpoint action - stopping the target - is represented
as a fragment of pseudo C code.
This is the
<blockquote>
<PRE>
#stop;
</PRE>
</blockquote>

<p>
line that appears in the source region when you add a breakpoint.

<p>
You can change this to a fragment of C code, editing the text
in the usual way by clicking the middle mouse button to
position a marker bar.
You can use the RETURN key to enter multi-line code fragments.
As with other editable fields, you end the edit with ESC.
If there is an error in the code, an error message is given
and the marker is positioned at the point of the error.

<p>
For example, you could change the breakpoint action to :
<blockquote>
<PRE>
printf("Entered function foo with x = 0\n", x);
</PRE>
</blockquote>

<p>
From now on, whenever the target reaches this point in the program,
it will call <tt>printf()</tt> rather than stopping.

<p>
Note that a breakpoint will not stop the target unless the special keyword
<TT>#stop</TT>
is executed.
You can use this to set conditional breakpoints, like :
<blockquote>
<PRE>
if (i == 72)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#stop;
</PRE>
</blockquote>

<p>
or, to use a more sophisticated example :
<blockquote>
<PRE>
if (strcmp(p-&gt;p_name, "foo") == 0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#stop;
</PRE>
</blockquote>

<p>
In the above examples, the function calls (<tt>printf()</tt> and <tt>strcmp()</tt>)
are implemented as calls to functions in the target.
You can call any target function from a breakpoint, but in the current
version of
<I>ups</I> all functions are assumed to return
<TT>int</TT>.
You can often get around this by casting the return value to the correct type.

<p>
One problem with calling functions like
<TT>printf()</TT>
to do diagnostic
output is that the output is mixed up with the normal output of the target
program.
If you want the output kept separate, use the built in
<I>ups</I> function
<TT>$printf</TT>.
This function creates a new region in the
<I>ups</I> window the first
time it is called, and sends output to that region.
The menu at the top of the region allows you to search for regular
expressions in the output, as well as page through it and clear
all output.

<p>
The
<TT>$printf</TT>
function takes the same format string as <tt>printf()</tt>,
with one addition.
The <tt>%v</tt> format string can be used with any variable type, and means
print in the default
<I>ups</I> format for the type.
The <tt>%v</tt> format character will print symbolic names for
<TT>enum</TT>
values and function pointers (<i>i.e.</i> you will get output like
<TT>RED</TT>
and
<TT>close_callback</TT>
rather than
<TT>23</TT>
and
<TT>0x5e748</TT>).
In addition <tt>%v</tt> applied to a struct or union pointer will print the
names and values of all the fields of the pointed-to struct or union.

<p>
You can declare your own variables in breakpoint code.
This is useful when you want only want to stop at a breakpoint
after it has been hit a given number of times.
A code fragment to do this would look something like:
<blockquote>
<PRE>
{
    static int count = 0;

    if (++count == 74)
        #stop;
}
</PRE>
</blockquote>

<p>
This would stop the target the 74th time the breakpoint was encountered.
Static variables are reinitialized every time the target is started.
Automatic variables are uninitialized and do not preserve their values
between separate executions of breakpoint code.

<p>
You can mix C interpreter variables with real target variables
in expressions in breakpoint code, with some restrictions.
You can assign to target variables, but making
a target pointer point at an interpreter variable will not work,
as interpreter variables do not exist in the target&acute;s address space.
On the other hand, the interpreter knows about the target address
space, so you can point interpreter variables at target variables.

<p>
<b>Note</b> that you can only
<I>add</I> interpreted code - you can&acute;t directly affect the flow of control
of the compiled code.
For example adding a
<TT>return</TT>
statement will
<I>not</I> cause the compiled function to return to the caller.
It is sometimes possible to indirectly affect the flow of control
by judicious changes to variable values.

<p>
You cannot add C interpreter variables to the display; if you click on
a variable in interpreted code it is taken to be a variable from the
target process.

<p>
[ <i>You probably want to skip this paragraph.</i> ]
<blockquote>
For people who want to live at the ragged edge, the C interpreter
uses copy-in copy-out semantics when passing interpreter addresses
to the target.
If you pass an argument of type
<TT>pointer to T</TT>
to a compiled target function then the interpreter copies
<TT>sizeof(T)</TT>
bytes to the target address space and passes a pointer to that copy.
When the target function returns the same number of bytes are copied
back from the target into the interpreter address space.
Similarly when you pass an array, the contents of the array are
copied in and out.
Note that this mechanism does not work in general - it only copes
with passing an array or a pointer to a single object.
The main motivation for this feature was to make string literals
(<i>e.g.</i> <TT>"hello"</TT>)
work as expected when passed to target functions like
<TT>strcmp()</TT>.
</blockquote>
</P>

<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->

<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<a name="EXAMINING LINKED DATA STRUCTURES"><H3>EXAMINING LINKED DATA STRUCTURES</H3></a>
</td></tr></table>

<p>
<I>Ups</I> has several facilities that are useful for examining linked data
structures.
Firstly, you can expand structures or structure pointers.
By repeatedly expanding structures you can follow down a linked list or tree.

<p>
Often this adds too much information to the display, as you are probably not
interested in all the structure elements.
There is a more selective method of expanding lists and trees which lets
you easily see just the elements you want.

<p>
Suppose you have a structure declaration like this:
<blockquote>
<PRE>
struct linkst {
    struct linkst *prev, *next;
    int key;
};
</PRE>
</blockquote>

<p>
Suppose also that you have a variable
<TT>linkptr</TT>
displayed which is a pointer to this structure.

<p>
If you type in a <tt>.</tt> followed by the name of element, such as
<TT>prev</TT>,
that element of any selected structures or structure pointers will be
added to the display and selected when you hit ESC.

<p>
Assume
<TT>linkptr</TT>
in the example above is displayed and selected.
Typing
<TT>.next</TT>
followed by ESC will add the
<TT>next</TT>
field of
<TT>linkptr</TT>
to the display and select it, and deselect
<TT>linkptr</TT>.
Typing ESC again will add the next element of the list.
Thus by repeatedly typing ESC you can easily walk down a linked list.

<p>
You can give many structure elements separated by spaces.
Thus the line
<blockquote>
<PRE>
.key .next
</PRE>
</blockquote>

<p>
would add both fields to the display.
In this way you can walk down a linked list with members of interest
displayed as well as the links.

<p>
One problem with this way of looking at lists is that the indentation
of structure elements tends to make the list wander off the right hand
side of the display area.
To avoid this you can say <tt>@member</tt> rather than <tt>.member</tt>.
The <tt>@</tt> character means do not indent - this is the only difference
between it and <tt>.</tt>.
Thus to get a nicely laid out list in the example above you could
enter the line :
<blockquote>
<PRE>
.key @next
</PRE>
</blockquote>

<p>
and keep typing ESC to walk down the list.

<p>
One last wrinkle: if you add <tt>#nnn</tt> to the end of the typing line, where
<tt>nnn</tt> is a decimal number, the effect is as if you had pressed ESC that
number of times.
This is handy if you want to see all of a 500 element linked list without
having to type ESC 500 times.

<p>
In C interpreter code (described in
<a href="#ADDING INTERPRETED CODE"><small>ADDING INTERPRETED CODE</small></a>)
you can scan through a linked list as if it were an array using the
(non-standard)
<tt>-&gt;[</TT><I>count</I><tt>]</tt>
operator.
This is a shorthand for applying the
<tt>-&gt;</TT>
operator
<I>count</I> times.
You can use the arrow keys (or ^N and ^P) as described in
<a href="#EXPRESSIONS IN THE DISPLAY AREA"><small>EXPRESSIONS IN THE DISPLAY AREA</small></a>
to bump the count parameter up or down and step through a linked list one
element at a time.

<p>
Thus in the example above, adding the following expression to the
display area :
<blockquote>
<PRE>
linkptr-&gt;[0]next
</PRE>
</blockquote>

<p>
would just show the value of
<TT>linkptr</TT>
(the
<TT>-&gt;</TT>
operator is being applied zero times).
You can expand the structure and add and delete elements to get the
display set up as you like.
Then you can edit the
<tt>0</TT>
to
<tt>1</TT>
to see the next element of the list, and so on.
</P>

<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->

<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<a name="DISPLAYING MEMORY"><H3>DISPLAYING MEMORY</H3></a>
</td></tr></table>

<p>
The contents of raw memory may be dumped to the output window in two ways.
If the memory to be dumped is the address of a simple variable or structure, or
is pointed to by a pointer variable, select the variable of interest,
press the 
<b>Expand</b>
option then select
<b>Dump Memory</b>
from the resulting popup menu.
This option displays the contents of memory at the selected address.
The length of memory displayed, and the grouping
(as bytes, shorts, or longs) is based on the type of object selected.
This option also prints in the output window the equivalent typing line
command, which you may copy to the typing line and edit as required.

<p>
The commands to display memory through the typing line begin with <tt>%d</tt>
(for dump) :
<blockquote>
<PRE>
%d  address [size|.. end_address]
     dump size bytes of memory at address
%db address [size|.. end_address]
     dump size bytes of memory as bytes at address
%ds address [size|.. end_address]
     dump size bytes of memory as shorts at address
%dl address [size|.. end_address]
     dump size bytes of memory as longs at address
</PRE>
</blockquote>
If the size is omitted, 16 bytes are displayed.
If the grouping is unspecified,
bytes or shorts are selected depending on target endidness.
</p>

<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->

<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<a name="ENVIRONMENT VARIABLES"><H3>ENVIRONMENT VARIABLES</H3></a>
</td></tr></table>

<p>
By default the target inherits the same set of environment variables as
<I>ups .</I> You can change this using the
<B>Environment</B>
object in the display area.
Any changes to the target environment take effect the next time the
target is started.

<p>
Selecting the
<B>Environment</B>
object produces a menu with the commands
<B>Expand</B>,
<B>Collapse</B>,
<B>Add entry</B>
and
<B>Reset env</B>.
The
<B>Expand</B>
command adds an entry to the display area for each environment variable.
You edit an environment variable name or value by clicking on it in the
normal way with the middle mouse button.
<B>Collapse</B>
removes all the entries from the display area.

<p>
To add a new entry select
<B>Add entry</B>
from the environment menu and type in the <tt><I>name=value</I></tt> string.
<I>Ups</I> will accept any string as an entry, but gives a warning for odd-looking
entries.

<p>
If you wish to abandon any changes you have made to the environment
select
<B>Reset env</B>.
This resets to the environment to the state it was in when
<I>ups</I> was started.

<p>
If you select an individual environment entry you get a menu with
the options
<B>Hide</B>,
<B>Delete</B>
and
<B>Append entry</B>.
The
<B>Hide</B>
command removes the entry from the display but not from the environment.
This is useful for clearing the display of uninteresting entries.
By contrast the
<B>Delete</B>
command removes the entry from the environment.
The
<B>Append entry</B>
command allows you to add a new environment variable just after the
one selected; this is useful if you need the environment set in a
particular order.
</P>

<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->

<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<a name="SIGNALS"><H3>SIGNALS</H3></a>
</td></tr></table>

<p>
When the target gets a signal control returns to
<I>ups</I>.
Depending on the signal and the way you have specified it should be handled,
the target is either stopped or restarted (possibly with a display refresh),
and the signal can either be passed on to the target or ignored.

<p>
Near the top of the main display area is a
<B>Signals</B>
object.
Selecting this produces a menu with
<B>Expand</B>
and
<B>Collapse</B>
as options.
Expanding the signals object produces a list of all signals, with the
current way the signal is handled displayed for each signal.
Selecting a signal produces a menu which lets you change the way it
is handled.

<p>
You can control whether a given signal causes
<I>ups</I> to stop the target,
refresh the display and continue the target or just continue the target
without refreshing the display.
You can also control whether the signal should be passed on to the target.

<p>
You can trim the signals display by selecting the ones you aren&acute;t
interested in and clicking on
<B>Hide</B>
in the signals menu.
This will remove those signals from the display area.

<p>
The
<B>Next</B>
and
<B>Step</B>
commands both step over functions called as a
result of a signal.
Breakpoints in signal handling functions work normally.
</P>

<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->

<table width=100% bgcolor=#ffffcc border=0 cellspacing=0>
<tr><td>&nbsp;</td></tr>
<tr><td align=center>
<a name="TYPING LINE SHORTCUTS"><H3>TYPING LINE SHORTCUTS</H3></a>
</td></tr></table>

<p>
A few frequent requests can be invoked by typing input as an alternative
to mouse operations.
<ul>
<li>
Typing <b><tt>%g</tt>&nbsp;<i>name</i></b> will display the global variable or
function <i>name</i>, skipping the
sometimes slow search for <i>name</i> as a local variable.
<p>
<li>
Typing <b><tt>%l</tt>&nbsp;<i>file</i></b> will list <i>file</i>, the same as
expanding the list of source files and clicking on a file name.
It is only necessary to enter the final component of the file name.
<p>
<li>
Typing <b><tt>%b</tt>&nbsp;<i>function</i></b> will enter a breakpoint at the
entry to <i>function</i>,
the same as clicking on the breakpoint header, selecting <b>add breakpoint</b>,
and entering the function name.
<p>
<li>
Typing <b><tt>%d</tt>&nbsp;<i>address</i></b> will dump 16 bytes of memory
at the given address to the output window.
See
<a href="#DISPLAYING MEMORY"><small>DISPLAYING MEMORY</small></a>
for more on the <tt>%d</tt> command.
<p>
<li>
Typing <b><tt>/pattern</tt></b> or <b><tt>?pattern</tt></b> will do a forward or backward
search for pattern.
The search may be continued in the same direction by hitting
RETURN, or in either direction using the <b>Search</b> pulldown menu.
</ul>
</p>
 
<!-- XXXXXXXX ------------------------------------------------------------- -->

<table width=100% bgcolor=#ffffcc border=0 cellspacing=0>
<tr><td>&nbsp;</td></tr>
<tr><td align=center>
<a name="X AND SUNVIEW COMMAND LINE FLAGS"><H3>X AND SUNVIEW COMMAND LINE FLAGS</H3></a>
</td></tr></table>

<p>
Under SunView
<I>ups</I> recognises the standard SunView tool flags.
These can occur anywhere on the command line.

<p>
Under X
<I>ups</I> recognises most common X11 command line arguments.
The currently recognised flags are :

<blockquote>
<dl>
    <dt><B>-iconic</B>
	<dd>Start up as an icon rather than as a window.
    <p>
    <dt><B>-display</B><I> displayname</I>
	<dd>Create a window on the named display rather than using the value
	of the <TT>DISPLAY</TT> environment variable.
    <p>
    <dt><B>-geometry</B><I> geometry</I>
	<dd>Use the specified X geometry for the window.
    <p>
    <dt><B>-name</B><I> name</I>
	<dd>Use <I>name</I> rather than the default <TT>ups</TT>
	as the window and icon name.
	This name is also used when fetching X defaults.
    <p>
    <dt><B>-fn</B><I> fontname</I>
	<dd>Use X font <I>fontname</I> rather than the default.
    <p>
    <dt><B>-fg</B><I> colorspec</I>
	<dd>Use <I>colorspec</I> (which should be a standard X11 color specification)
	as the color of the foreground pixel.
    <p>
    <dt><B>-bg</B><I> colorspec</I>
	<dd>Use <I>colorspec</I> as the color of the background pixel.
    <p>
    <dt><B>-rv</B> </TD><TD valign=bottom>
	<dd>Reverse the foreground and background pixel colors.
</dl>
</blockquote>

<p>
These options are available under X and SunView :

<blockquote>
<dl>
    <dt><B>-mono</B>
	<dd>Force monochrome mode even if when using a color display.
	Use this flag to stop
	<I>ups</I> interfering with the colormap on pseudocolor displays (<i>e.g.</i> when
	you are debugging a program with a colormap related problem).
	The flag is also useful on some Sun displays under SunView where
	using monochrome significantly increases the display speed.
    <p>
    <dt><B>-wn_record</B> <I>filename</I>
	<dd>Record mouse and keyboard events in file <I>filename</I>.
    <p>
    <dt><B>-wn_replay</B> <I>filename</I>
	<dd>Read mouse and keyboard input from file
	<I>filename</I> rather than the mouse and keyboard.
	The file <I>filename</I> must have been created with the
	<B>-wn_record</B> flag in a previous session.
    <p>
    <dt><B>-wn_replay_warp</B>
	<dd>When replaying events with <B>-wn_replay</B>, warp the mouse in the
	<I>ups</I> window to reflect the recorded mouse movement events.
</dl>
</blockquote>
</p>

<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->

<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<a name="X RESOURCES"><H3>X RESOURCES</H3></a>
</td></tr></table>

<p>
<I>Ups</I> recognises a number of X defaults.
By default it uses the last pathname component of the name you run
it with as the application name when looking up resources (<i>i.e.</i> if
you run it as <tt>/usr/bin/ups</tt> it will use <tt>ups</tt>).
You change the name with the
<B>-name</B> flag described above.
If it fails to find a resource with the application name,
<I>ups</I> does a lookup using <tt>Ups</TT> (note the initial upper case letter).
A resource specified as <tt>Ups.</TT><I>xxx</I></tt> will thus always be noticed.
Finally
<I>ups</I> looks in the resource file
<TT>/usr/lib/X11/app-defaults/Ups</TT>
if a resource is not found anywhere else.
(In addition to the above directory, ups looks for the file
<I>Ups</I>
in the colon separated list of directories given by the environment
variable <tt><small>XUSERFILESEARCHPATH</small></tt>, and in the single directory given by the environment
variable <tt><small>XAPPLRESDIR</small></tt>.)

<p>
The current list of recognised resources is :

<blockquote>
<dl>

    <dt><B>Font</B> </TD><TD valign=bottom>
	<dd>The name of the normal font.
	The default is <tt>fixed</tt>.

    <p>
    <dt><B>MenuFont</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>The font used for menu captions.
	The default is to use the normal font.

    <p>
    <dt><B>SrcFont</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>The font used for text in the source window.
	The default is to use the normal font.

    <p>
    <dt><B>EditFont</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>The font used for editable text in the source window.
	The default is a bold version of the normal font (using the name
	formed by replacing
	<TT>medium</TT>
	with
	<TT>bold</TT>
	in the font name).
	If this substitution cannot be made,
	<I>ups</I> tries
	<TT>-*-fixed-bold-r-normal--15-*-*-*-*-*-*-*</TT>.
	If this font is unavailable,
	<I>ups</I> complains and uses the normal font.

    <p>
    <dt><B>Foreground</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>The color of the foreground pixel.
	The default is whatever the
	<TT>BlackPixel</TT>
	macro returns for the display.

    <p>
    <dt><B>Background</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>The color of the background pixel.
	The default is whatever the
	<TT>WhitePixel</TT>
	macro returns for the display.

    <p>
    <dt><B>ReverseVideo</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>If this is set (to anything) it has the same effect as the
	<B>-rv</B> flag.

    <p>
    <dt><B>Geometry</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>The size and (optionally) position of the main
	<I>ups</I> window.
	The default is to suggest to the window manager a window 580 pixels wide
	by 550 pixels deep at a user-specified position.
	Most window managers will of course let you sweep out a window of the
	size you require.
	<br>
	In the split window modes, the source and output windows have their
	own geometry resources.
	Set the resource <b>Ups.Src.Geometry</b> to specify
	a geometry for the <i>ups</i> source window, and <b>Ups.Output.Geometry</b> to specify
	the geometry for the <i>ups</i> output window.
	Or set the resource <b>Ups*Geometry</b>
	to specify the same geometry for all <i>ups</i> windows.

    <p>
    <dt><B>EditlinesColor</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>The color used for editable text in the source window.
	The default is blue.

    <p>
    <dt><B>ColorVars</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>Can be set to <tt>off</tt> to disable coloring of variable names.

    <p>
    <dt><B>VariableColor</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>The color used for variable names in the display area.
	The default is purple.

    <p>
    <dt><B>HighlightColor</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>The color used to highlight variables in the display area whose
	values have changed since the last time the target stopped.
	The default is red.

    <p>
    <dt><B>WantMenuColors</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>If set to <tt>yes</tt>, <i>ups</i>
	will use foreground and background menu colors as listed below.
	If not set to <tt>yes</tt>, such settings are ignored, and the 
	<b>Foreground</b> and <b>Background</b> resources are used.

    <p>
    <dt><B>MenuForeground, MenuBackground</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>The default colors for text and background in all buttons and menus. 
	Sub menus inherit the colors of their parents unless specifically overwritten.

    <p>
    <dt><B>DisabledTextColor</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>The color for text that is disabled, such as the <tt>start</tt> caption 
	after starting the target, or globally disabled breakpoints.

    <p>
    <dt><B>LastButtonTextColor</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>The text color of a busy button pressed (such as <b>cont</b> 
	while the target is executing) or the parent menu item of
	a sub menu.

    <p>
    <dt><B>SourceMenuForeground, SourceMenuBackground</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>The text and background colors of the pop up menu for the source
	window.

    <p>
    <dt><B>CustomMenuForeground, CustomMenuBackground</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>The text and background colors 
	of the custom pop up menu for editing text strings.

    <p>
    <dt><B>FileBoxMenuForeground, FileBoxMenuBackground</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>The text and background colors of the pop up menu for the file name and 
	line number box that is directly above the source window.

    <p>
    <dt><B><i>text caption</i>Foreground, <i>text caption</i>Background</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>The text and background colors for a menu item with a specific text caption: 
	for example <tt>Add breakpointForeground</tt>.
	Note that embedded spaces are allowed.

    <p>
    <dt><B>AsteriskForeground, AsteriskBackground</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>The text and background colors of the <b>*</b> menu caption that appears
	when selecting a variable. This caption uses a special resource name
	in order to resolve a conflict with main foreground and background resources.

    <p>
    <dt><B>WantExtendedTextColors</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>If set to <tt>yes</tt>, <i>ups</i>
	will use the colors for the text items in the display window 
	as listed below.
	If not set to <tt>yes</tt>, such settings are ignored.

    <p>
    <dt><B>SignalTextColor</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>The text color of the signals listed under the <tt>Signal</tt> header.

    <p>
    <dt><B>EnvironmentTextColor</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>The text color of environment strings listed under the <tt>Environment</tt> header.

    <p>
    <dt><B>SourceFileTextColor</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>The text color of the file names listed under the <tt>Source files</tt> header.

    <p>
    <dt><B>FunctionTextColor</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>The text color of the function names in the stack under the <tt>Functions</tt> header.

    <p>
    <dt><B>BreakpointTextColor</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>The text color of active breakpoints listed under the <tt>Breakpoints</tt> header.
	Inactive breakpoints are in the main foreground color, as is the text
	of breakpoint code in the source window.

    <p>
    <dt><B>MouseholeWidth</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>The width of the mousehole in pixels.

    <p>
    <dt><B>WantMousehole</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>If this is set to <tt>yes</tt> the mousehole is removed from the display.
	This is useful if you use a large font and find the typing line is
	too small.

    <p>
    <dt><B>TypingLineOnRight</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>If this is set to <tt>yes</tt>, the top line of <i>ups</i> is flipped left to right
	so that the mousehole (if not disabled) is on the left, then the
	permanent menu, then the history and enter buttons, then the typing line.
<!--
	Use of this resource is suggested in conjunction with the <b>DisableMousehole</b>
	resource to keep popup menus from disappearing.
-->

    <p>
    <dt><B>PermanentMenuWidth</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>The width of the permanent menu (<tt>Quit</tt>, <tt>Help</tt> <i>etc.</i>) in pixels.

    <p>
    <dt><B>SelectionThreshold</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>The number of pixels to move right in order to activate text selection
	in the display window.
	Default is 30.

    <p>
    <dt><B>NonFrameFunctions</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>When set to <tt>on</tt>,
	<I>ups</I> does different processing of non frame (or frameless) pointer functions.
	This will normally make
	<I>ups</I> work better with software that inserts calls into the object code,
	such as Purify Purecov and Quantify.
	This should fix truncated stacks and
	anomalous <tt>next</tt> and <tt>step</tt> behaviour when debugging such code.
	However,
	it occasionally causes problems with ordinary targets, so this feature
	is disabled by default.
	<I>Ups</I> will automatically set the value to <tt>on</tt> if it detects the presence
	of Purify Purecov and Quantify.
	A value of <tt>off</tt> explicitly
	overrides such automatic setting.

    <p>
    <dt><B>ScrollbarType</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>Controls the scrollbar behavior.
	If set to anything other that <tt>UPS</tt>,
	such as <tt>MOTIF</tt>, then scrolling will move the viewport in the opposite
	direction to the mouse movement, this being the convention used by most X
	toolkits (for better or worse).

    <p>
    <dt><B>ScrollbarWidth</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>The width of all the scroll bars in pixels.

    <p>
    <dt><B>ScrollDelay</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>Set this if scrolling is too fast.
	A value of 25 or 50 is usually sufficient.

    <p>
    <dt><B>SrcwinNameWidth</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>The width in pixels of the box above the source window containing
	the current source file name and line number.

    <p>
    <dt><B>SrcwinPercent</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>The percentage of the window height used for the source window (after
	space used by the fixed size regions is subtracted).
	The default is 50 (<i>i.e.</i> half).
	<B>DisplayAreaPercent</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	The percentage of the window height used for the display area (after
	space used by the fixed size regions is subtracted).
	The default is 50 (<i>i.e.</i> half).
	If <B>DisplayAreaPercent</B> and
	<B>SrcwinPercent</B> are both set they need not add up to 100 - the values actually
	specify a proportion of the total.
	Thus setting both to 20 (or any pair of identical values) results
	in a 50-50 split.

    <p>
    <dt><B>OutwinPercent</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>The percentage of the window height used for the output window
	if and when it is added.
	The default is 10 (which actually means a tenth of the total -
	see the note about <B>SrcwinPercent</B> above.

    <p>
    <dt><B>EnterButtonWidth</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>The width of the text entry button in pixels.

    <p>
    <dt><B>HistoryButtonWidth</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>The width of the history button in pixels.

    <p>
    <dt><B>WantSplitWindows</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>If this is set to <tt>yes</tt> then <i>ups</i> will start up with
	two windows.  The source window, source menu, target menu,
	and output window and menu (if used) will be in one frame.
	The display window and the permanent menu (<tt>Quit</tt>, <tt>Help</tt> <i>etc.</i>) and
	dynamic menus (<tt>Expand</tt>, <tt>Collapse</tt> <i>etc.</i>)
	will be in another frame.
	The same effect can be achieved by using the 
	command line option <b>-split</b>.
	To request a screen number for the second window,
	use the form <tt>yes:</tt><i>screen number</i>.

    <p>
    <dt><B>WantSplitOutputWindows</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>If this is set to <tt>yes</tt> then
	<I>ups</I>
	will come up with 2 windows, or 3 windows if <b>WantSplitWindows</b> is also set,
	with separate frame for the output window.
	The same effect can be achieved
	by using the command line option <b>-splitoutwin</b>.
	To request a screen number for the second window, use the form <tt>yes:number</tt>.

    <p>
    <dt><B>WantLogging</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>If this is set to <tt>yes</tt>,
	<i>ups</i>
	will come up with error messages
	logged to the output window.
	The same effect can be achieved by using the
	command line option <b>-logging</b> or during the session by turning on the <b>Message
	Logging</b> option under the <tt>Windows</tt> popup menu.

    <p>
    <dt><B>WantRaiseOnBreak</B>, <B>WantLowerOnRun</B>, <B>WantIconifyOnRun</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>These resources set the initial state of the <b>Raise On Break</b>
	family of options in the <tt>Windows</tt> popup menu.
	These should be set to <tt>yes</tt> or <tt>no</tt>
	as to whether and how
	<i>ups</i>
	should manipulate its windows when the target
	process goes in or out of run.
	All are set to <tt>no</tt> by default.
	These are evaluated in the order listed, the last of these options set
	to <tt>yes</tt> being the initial state of the Raise On Break option.

    <p>
    <dt><B>LowerOnRunTime</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>When the <b>Lower</b> or <b>Iconify on Run</b> options in the
	<tt>Windows</tt> popup menu are active,
	this resource sets the time in milliseconds that
	<i>ups</i>
	waits for the process to break before lowering or iconifying itself.
	The default value is 1500, that is, a 1.5 second delay.

    <p>
    <dt>...<B>Row</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>The default vertical position of the objects in the display window
	can be specified by the following ...<b>Row</b> resources.
	Legal values are 1 to 9 inclusive: 1 indicates the top row and 9 the
	bottom.
	Only rows of interest need to be specified.
	Other rows are positioned according to their default values.
	For example, if one wants to put the
	breakpoints above the function stack (and one is not using Fortran),
	use:
	<blockquote>
	<tt>Ups*BreakpointsRow: 6</tt>
	</blockquote>
	<dl>
	<dt><b>TargetRow</b>
	    <dd>The vertical position of the 
	    <b>Target</b> 
	    header in the display window. Default is 1. Note 
	    that this is a double height row.
	<dt><b>SignalsRow</b>
	    <dd>The vertical position of the 
	    <b>Signals</b> 
	    header in the display window. Default is 2.
	<dt><b>EnvironmentRow</b>
	    <dd>The vertical position of the 
	    <b>Environment</b> 
	    header in the display window. 
	    Default is 3.
	<dt><b>UntypedVariablesRow</b>
	    <dd>The vertical position of the 
	    <b>Untyped variables</b> 
	    header in the display window. 
	    Default is 4.
	<dt><b>SourceFilesRow</b>
	    <dd>The vertical position of the 
	    <b>Source files</b> 
	    header in the display window. 
	    Default is 5.
	<dt><b>ModulesRow</b>
	    <dd>The vertical position of the 
	    <b>Modules</b> 
	    header in the display window, for
	    targets using Fortran modules. Default is 6.
	<dt><b>CommonBlocksRow</b>
	    <dd>The vertical position of the 
	    <b>Common blocks</b> 
	    header in the display window, for
	    targets using Fortran common blocks. Default is 6 if no modules exist,
	    7 otherwise.
	<dt><b>FunctionsRow</b>
	    <dd>The vertical position of the 
	    <b>Functions</b> 
	    header in the display window. 
	    Default is 6 for non-Fortran targets, 7 or 8 if the target has Fortran  modules 
	    or common blocks.
	<dt><b>BreakpointsRow</b>
	    <dd>The vertical position of the 
	    <b>Breakpoints</b> 
	    header in the display window. 
	    Default is 7 for non-Fortran targets, 8 or 9 if the target has Fortran modules 
	    or common blocks.
	</dl>

    <p>
    <dt><B>WantTypedefs</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>If this is set to <tt>no</tt>, then
	<I>ups</I> will not attempt to use typedefs in display area variable declarations.
	See <B>Use of typedefs</B> in the
	<a href="#CONTROLLING THE DISPLAY OF VARIABLES"><small>CONTROLLING THE DISPLAY OF VARIABLES</small></a>
	section.

    <p>
    <dt><B>TabWidth</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>The width in characters of a tab character (for use in the source
	window).
	The default is eight.

    <p>
    <dt><B>UseMono</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>If this is set to <tt>yes</tt> then
	<I>ups</I> will always use mono even on colour displays.
	This resource has the same effect as the <B>-mono</B> flag (see above).

<!-- .\" AMC Enhancements -->
    <p>
    <dt><B>MultiClickTime</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>This resource specifies the maximum time in milliseconds between
	multi-click events.
	The default is 250 milliseconds.

    <p>
    <dt><B>BreakPointAcceleratorAction</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>This resource selects the accelerator action when shift-clicking or
	double clicking on a breakpoint in the source code or display area.
	The resource may be set to <tt>Toggle</tt>, to toggle the breakpoint between
	the active and inactive states, or <tt>Remove</tt> to remove the breakpoint.
	The default is to toggle the breakpoint.

    <p>
    <dt><B>BreakPointHeaderAcceleratorAction</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>This resource selects the accelerator action when shift-clicking or
	double clicking on a breakpoints header in the display area.
	The resource may be set to <tt>Toggle</tt>, to toggle the global breakpoint between
	the active and inactive states, or <tt>Add</tt> to to add a new breakpoint.
	The default is to toggle the global breakpoint state.

    <p>
    <dt><B>SourceMenuDefault, AltSourceMenuDefault</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>These resources control the default action when clicking the right
	mouse button in the source window to quickly select from the pop-up
	menu (without taking the time to actually select something).
	The <b>AltSourceMenuDefault</b> resource, if used,
	controls the selection when shift-clicking,
	while the <b>SourceMenuDefault</b> controls the selection otherwise.
	If <b>AltSourceMenuDefault</b> is not used, then <b>SourceMenuDefault</b>
	controls both; if <b>SourceMenuDefault</b> is not used,
	it defaults to <tt>LastSelection</tt>.
	<p>
	Possible values are:
	<blockquote>
	<dl>
	    <dt><tt>LastSelection</tt>
	    <dd>Selects the most recently selected value.
	    <br>
	    <dt><tt>ResetDefault</tt>
	    <dd>For the <b>AltSourceMenuDefault</b> resource only, causes the a selection made with
	    shift button depressed to reset the default option used when quickly
	    clicking.
	    <br>
	    <dt><tt>AddBreakPoint</tt>
	    <dd>Selects the Add BreakPoint option.
	    <br>
	    <dt><tt>ExecuteToHere</tt>
	    <dd>Selects the Execute to here option.
	    <br>
	    <dt><tt>JumpToHere</tt>
	    <dd>Selects the Jump to here option.
	    <br>
	    <dt><tt>EditFile</tt>
	    <dd>Selects the Edit file option.
	</dl>
	</blockquote>
    <p>

    <dt><B>TypingLineHistorySize</B> </TD></TR><TR valign=top><TD width=6%>&nbsp;</TD><TD>
	<dd>Sets the number of entries in the typing line history buffer.
	There are also resources to control the other edit histories.
	To determine their names, find the name of the history
	in the edit history file and append <tt>HistorySize</tt>.

</dl>
</blockquote>
</p>

<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->

<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<a name="DEBUGGING FORTRAN CODE"><H3>DEBUGGING FORTRAN CODE</H3></a>
</td></tr></table>

<p>
<I>Ups</I> has support for debugging code written in Fortran 77 and Fortran 90.
The Fortran 77 support works with most compilers.
The Fortran 90 support has only been tested with the
<I>epcf90</I> compiler running under SunOS 4.1.3.

<p>
The most visible difference with Fortran code is that variable types
are displayed using Fortran rather than C syntax.
Thus a typical stack display might look like :
<blockquote>
<PRE>
<B>Functions</B> 
MAIN
  double precision acctim               0.0
  integer*4 count                       0
  double precision table(168,10) [1,1]  0.0
  logical dotrace                       .false.
</PRE>
</blockquote>

<p>
Variable names will usually be shown in lower case, even if you have
used upper case in the source code.
This transformation is done by the compiler, and
<I>ups</I> has no control over it.

<p>
Notice that there are two sets of subscripts shown for the array
<TT>table</TT>.
The first set (in round brackets) show the actual size of the array.
The second set shows the subscript of the element that is being
displayed.
These can be edited to show different elements in the same way as with C arrays.

<p>
If the program has any common blocks, these are shown under a
<B>Common blocks</B>
object in the display area.
This can be expanded to show the list of common blocks, and individual
common blocks can be expanded in turn to show the variables.
If a given common block is declared differently in different
functions, each different declaration gets its own entry in the list.
Thus you might see :
<blockquote>
<PRE>
<B>Common blocks</B> 
  common /supp_defs/ (as defined in MAIN)
  common /supp_defs/ (as defined in foo)
</PRE>
</blockquote>

<p>
Fortran 90 user defined types are treated in much the same way as C structures.
You can recursively expand them to follow linked lists and such.

<p>
If you are using Fortran 90 modules,
<I>ups</I> adds a
<B>Modules</B>
object to the display area.
You can expand this to show a list of modules.
Module names can be expanded in their turn to show a list of functions
and subroutines defined within the module.
In the current version module variables are not displayed under the
appropriate module heading; instead they appear under a common block
entry.
This will be fixed in a future release.

<p>
There is currently no support for interpreted code under Fortran.
Nor can you add Fortran expressions to the display area.
This will be fixed if and when someone writes a Fortran interpreter
for <I>ups</I>.
</P>

<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->


<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<a name="SUPPORT FOR C++"><H3>SUPPORT FOR C++</H3></a>
</td></tr></table>

<p>
<I>Ups</I> provides reasonable support for debugging C++ code compiled
with <tt>cfront</tt> version 3, the Sun SC4 ompiler, and the GNU g++ compilers. 

<p>
For C++ code, <i>classes</i> are shown as <i>structs</i>
with the methods invisible.
Function and variable names are demangled.
The function stack and the breakpoint list use the <tt>class::method</tt>
syntax.
A restriction is that it is not possible to debug <i>class templates</i>.
To debug executable code in header files, such as accessor functions defined
in the class definition, turn off in-lining when compiling.

<p>
Function names in wrapper modules are unmangled and present no problems.

<p>
When you
click on symbols in C++ source, <I>ups</I> searches local variables, and
if that fails, it searches fields in the <i>this</i> pointer, and finally
it searches for globals.
In addition it searches in all unions for matching
components - that is, the union tag does not have appear in the source.
When breakpoints are set on overloaded methods in C++ code, <I>ups</I> queries
whether to place breakpoints on all matching names.

<p>
The <b>tags</b> operation works fairly well for C++ code.
This is
the facility that allows easy navigation through source code by simply
clicking on a function name.
You can click on methods and it will usually take
you to the source.
The <b>back</b> button returns to the original code.
The target needs to be running to get it to work so it can look up
the classes of variables.
It won&acute;t always get it right for inherited
or virtual methods, but it is still a quick and useful way of navigating
the code.
You may have to click twice sometimes to first get it read
a variable.
If the source is in a library with no debug information,
the message line will show the method name in the library.

<p>
In <b>add expr</b> and breakpoint code you can cast to un-typdef&acute;ed
<i>structs</i>, including <i>classes</i> in C++.
Examples are  <tt>(Class*)</tt><i>name</i>
where <i>name</i> is a variable, or
<tt>(Class*)0x765678</tt> for a numeric address.
If you want to cast
to a class that is undefined in the current context, try an <tt>add expr</tt>
for the source file where the constructor is defined.
This generally works,
at the file level, but not always.
It should always work for <tt>add expr</tt>
in the constructor though.
If you don&acute;t know which file the constructor is
defined in, enter the constructor name in the top typing line and
press RETURN or ESC.
The file name will be displayed just above the source window.
You can then expand the source file list to find the file, select it, and
enter the <tt>add expr</tt> code.

<p>
When a class is expanded in the display window, members of other
classes are show as <tt>struct class_name &lt;member&gt; value</tt> or perhaps as
<tt>undefined struct class_name  &lt;member&gt; value</tt>.
The class of the member
is therefore the struct name, and the methods for that class can be listed
as shown above.

<p>
You can set breakpoints on <tt>cout</tt> statements in C++ code in <I>ups</I> by
breaking on the overloaded <tt>&lt;&lt;</tt> operator.
The general
form of setting breakpoints in the display window of <I>ups</I> is :
<blockquote>
<PRE>
&lt;filename&gt;:function
</PRE>
</blockquote>

<p>
The simplest way of breaking on <tt>cout</tt> statements in C++ code is :
<blockquote>
<PRE>
ostream::operator&lt;&lt;
</PRE>
</blockquote>

<p>
Output can be flushed with a call to <tt>ostream::flush(&amp;cout)</tt>.

<p>
Similarly, in breakpoint code, character output can be sent to <tt>cout</tt> with the
following syntax :
<blockquote>
<PRE>
ostream::operator&lt;&lt;(&cout, "some text");
</PRE>
</blockquote>
You can include standard sequences such as <tt>\t</tt> and <tt>\n</tt>
in the text.

<p>
For character input, the syntax is similar :
<blockquote>
<PRE>
istream::operator&gt;&gt;(&cin, &buffer);
</PRE>
</blockquote>

<p>
where <tt>buffer</tt> is some suitable character storage.
Note that the code
is linked with just the first overloaded methods in the <i>iostream</i>
libraries, which is typically <i>(const char*),</i> so it won&acute;t work for other data
types.

<p>
Application defined operator methods can have breakpoints set
in the same fashion.
<I>Ups</I> asks whether to place
breakpoints on all matching strings, so a string like
<tt>class::operator</tt> can place breakpoints on all operator methods of
the class.
If you just want a particular one, such as <tt>==</tt>, then
add this at the end, <i>i.e.</i> <tt>class::operator==</tt>.

<p>
For <i>cfront</i> compiled C++ code, clicking on a variable name in the source
window will case <I>ups</I> to find all matching names, including matches in the
implicit <i>this</i> pointer as well as automatics.

<p>
</P>

<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->

<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<a name="SUPPORT FOR ROGUE WAVE RWCStrings"><H3>SUPPORT FOR ROGUE WAVE RWCStrings</H3></a>
</td></tr></table>

<p>
To support the popular the Rogue Wave Class library, there is a
new <b>format</b> type for seeing the string in a <i>RWCStrings</i> object.
Simply click on the object in the source window, then with the <b>format</b>
caption at the top, select <b>RWCString</b> under the <b>other</b> menu.
Despite
its position within this menu, this
is not just a format function, rather a macro that does selective
expansion, dereferencing, subscript bumping followed by casting.
As for all other objects in the display window, multiple <i>RWCString</i> objects
may be selected, formatted as strings, and then collapsed as one group
of objects.

<p>
To use a <i>RWCString</i> from <b>add expr</b> or breakpoint code, the address of the <tt>refs_</tt>
field of the second <tt>pref_</tt> component needs to be cast to a string.
So if <tt>rwc_string</tt> is a <i>RWCString</i>, use :
<blockquote>
<PRE>
(char *)&(rwc_string.pref_+1)-&gt;refs_
</PRE>
</blockquote>
</P>

<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->


<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<a name="INITIALIZATION FILE"><H3>INITIALIZATION FILE</H3></a>
</td></tr></table>

<p>
The debugger reads an initialization file of name <tt>.upsinit</tt> in
the users home directory upon invocation.
It can also be re-read on demand
during a debug session by selecting the
<B>Target</B>
object and selecting the
<B>Rescan init file</B>
caption.
This is convenient
for adding new source paths or loading additional libraries on the fly.
A missing library is indicated by the  stack displaying a
<tt>&lt;bad&nbsp;text&nbsp;address&nbsp;...&gt;</tt>
symbol, as well as the files of such libraries
not being shown in the source files listing.
After the rescan, the source
files and stack are redisplayed to reflect the new libraries
and source paths.

<p>
The easiest way of creating such a file is by
using the undocumented <tt>-record</tt> command line option.
An example
is <tt>ups target -record ~/.upsinit</tt>
The record file must not exist before it is created.
When <I>ups</I> is next invoked, with a command like <tt>ups target</tt>, it will read the
commands in <tt>$HOME/.upsinit</tt>
if such a file exists.
The record mode does not support interactions with the output window
menus at present, nor <tt>search</tt> menus with the source window,
Similarly mouse button modifiers are not recorded.
Such actions will be ignored when the file
is read.
The following is an example of an initialization file that
sets the <tt>SIGBUS</tt> and <tt>SIGSEGV</tt> signals to <tt>accept</tt> :
<blockquote>
<PRE>
select sghead
menu sghead show_all_signals
select sghead|sigbus
addselect sghead|sigsegv
menu signal toggle_accept_ignore
select sghead
menu sghead hide_all_signals
menu pmenu quit_ups
</PRE>
</blockquote>

<p>
The last line, to quit the debugger, should be deleted with a text editor after
creation.
Some of the most commonly used syntax is :
<blockquote>
<tt>breakpoint</tt> <i>filename func_name line_no</i>
<br>
<tt>menu</tt> <i>menu_name action</i>
</blockquote>

<p>
There are four other commands that can be specified in the <tt>~/.upsinit</tt>
file.
These are :
<blockquote>
<table>
<tr>
    <td><tt>use</tt></td>
    <td>&lt;<i>directory</i>&gt;</td>
</tr>
<tr>
    <td><tt>load</tt></td>
    <td>&lt;<i>string</i>&gt;</td>
</tr>
<tr>
    <td><tt>noload</tt></td>
    <td>&lt;<i>string</i>&gt;</td>
</tr>
<tr>
    <td><tt>break</tt></td>
    <td><i>function</i></td>
</tr>
</table>
</blockquote>
These are used respectively to specify paths to search for sources,
libraries to load or not load when reading symbols, and functions in which to
set breakpoints.
The source paths are needed for Centerline C++ because clcc typically creates
C files in temporary directories, and the symbol tables suggest that this is
where the parent C++ files are too.
This is not a problem for SC4 or g++
however.
The <tt>use</tt> command is equivalent
to the colon separated list of directories that can be given on the command
line for invoking <I>ups</I>, or during debugging with the
<B>add source path</B> caption.

<p>
The <tt>load</tt> and <tt>noload</tt> allow you to just
load symbols for the debugging area of interest, instead of always
loading everything.

<p>
By ignoring all libraries of no interest, <I>ups</I> can be attached to even
large targets (10s of megabytes)
quite quickly.
When all the long C++ names are ignored, the debugger is
a quick as it was before with a pure C target in respect to setting
breakpoints are examining data.
The stack trace will show <tt>&lt;bad&nbsp;text&nbsp;address&nbsp;...&gt;</tt>
for functions in unloaded libraries.

<p>
A caveat with using <tt>noload</tt> is that this causes <I>ups</I> to skip all information
for the specified library, so functions and files for unloaded libraries
will be invisible.
Attempts to set breakpoints on such functions
will results in <tt>no such function</tt> messages, and the files will not
appear in the source file list.

<p>
The <tt>load</tt> and <tt>noload</tt> keywords cannot be used together.
Specifying neither
means that all symbols are loaded.
Wildcards can be used at the beginning or end
of the string.

<p>
You can see all the symbol table names that are loaded and not loaded by doing a
<tt>setenv VERBOSE 1</tt> before calling <I>ups</I>.
Setting <tt>VERBOSE</tt> to <tt>NOLOAD</tt> causes
to list just the libraries that are not loaded.

<p>
You can specify breakpoints
with the syntax <tt>break</tt>&nbsp;<i>function</i>.
Unlike the <tt>-record</tt> style syntax, this
does not require a file or a line number, hence the same breakpoints
will work on different versions of the target source, provided the
functions exist.
<I>Ups</I> will silently skip breakpoints that it cannot set.
The limitation is that the breakpoint
will always be set at the beginning of the function.

<p>
This is an example <tt>.upsinit</tt> file loads symbols for the target,
C run-time library, and the <tt>dl</tt> library only,
and sets a breakpoint in <tt>main()</tt>.
<blockquote>
<PRE>
# path to find sources for the C++ files
use &lt;directory spec&gt;
use &lt;directory spec&gt;
use &lt;directory spec&gt;
# just load the symbols for these ...
load /usr/lib/libc*
load /usr/lib/libdl*
break main
</PRE>
</blockquote>
</P>

<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->


<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<a name="MULTIPLE LINKED FILES"><H3>MULTIPLE LINKED FILES</H3></a>
</td></tr></table>

<p>
<I>Ups</I> now with multiple linked files.
For such files, at least two versions of the code exist in the target.

<p>
<I>Ups</I> makes all duplicate files visible, with automatic replication
in the duplicate file of any setting or modification of a multiple linked function
breakpoint.
In this manner, all breakpoint code is kept identical between
duplicate files, and all breakpoints should be honored.

<p>
What this means in practice when using <I>ups</I> is that multiple linked function files are
listed twice in the source file listing.
Either one can be used to set a
breakpoint, and a second breakpoint will be created automatically in the
duplicate file.

<p>
The following actions maintain this automatic shadowing :

<ul>
<li>
    Selecting a file and setting a breakpoint with the right mouse button in the source window.
<p>
<li>
    Setting a breakpoint by selecting the <b>Breakpoints</b> header and then pressing
    the <B>Add new</B> caption (or SHIFT left accelerator on
    the <b>Breakpoints</b> header).
<p>
<li>
    Deleting a breakpoint.
<p>
<li>
    Renaming a breakpoint (works for all transitions between single instance and duplicate functions).
<p>
<li>
    Changing the line number of a breakpoint.
<p>
<li>
    Changing the activation state of a breakpoint.
<p>
<li>
    Selecting a file and using the right mouse button menu in the source window to <tt>execute to here</tt>.
</ul>
</P>

<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->

<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<a name="SAVING STATE"><H3>SAVING STATE</H3></a>
</td></tr></table>

<p>
When you quit
<I>ups</I>, it normally forgets things like breakpoint locations and the way your
variables are displayed.
This can be a nuisance, especially if you have added interpreted code,
or typed long expressions into the display area.
To preserve these settings,
<I>ups</I> will optionally save state information when you quit it, and reload
this information when you start it again.

<p>
In addition, a state file can be explicitly created or loaded at any time
by selecting the target name at the top of the display region.
This
will create a menu with four captions:
<B>Write target core</B>,
<B>Save state</B>,
<B>Load state</B>,
and
<B>Rescan init file</B>.
Clicking on
<B>Write target core</B>
prompts you for a file name in which <I>ups</I> will save the current
image of the target as a core file.
Selecting
<B>Save state</B>
prompts you for a file name in which to save the current debugger state.
Selecting
<B>Load state</B>
asks for a state file name which will be then loaded.
<B>Rescan init file</B>
will re-read your <tt>~/.upsint</tt> file, if it exists.

<p>
This section describes how this state is saved and restored.

<p>
If the directory
<TT>ups-state</TT>
exists in the current directory, <i>ups</i>
will use it to store state information between sessions.
This includes breakpoint locations
(and the interpreted code, if any), and the state of the
variables display.

<p>
The saved state is used in several ways :
<ul>
<li>
    After starting ups, you can select
    <B>Restore</B>
    from the
    <B>Breakpoints</B>
    menu to put breakpoints back as they were
    from the previous session.
    <i>Ups</i> tries to put
    breakpoints back in the right places, but it can be
    defeated by major changes to the source code.
<p>
<li>
    The default for the
    <B>Expand</B>
    option for stack trace and source file entries is
    <B>Like before</B>.
    This adds variables as they were in the last time you looked at them.
    If the
    <TT>ups-state</TT>
    directory exists, the state of the variables display is remembered
    across different
    <I>ups</I> sessions.
<p>
<li>
    When you add a variable the display format (hex, octal
    <i>etc.</i>) is taken from the way it was last time you
    displayed the variable.
<p>
<li>
    The attributes for signal handling are restored (<i>i.e.</i>, whether accepted,
    ignored, cause the process to stop).
</ul>

State is saved to the file
<TT>ups-state/</TT><I>xxx</I><tt>.state</tt>, where
<I>xxx</I> is the last component of the path of the file you are debugging.
You can also create the file
<TT>ups-state/</TT><I>xxx</I><tt>.config</tt>
(perhaps by copying
<TT>ups-state/</TT><I>xxx</I><tt>.state</tt>).
The
<TT>.config</TT>
file is read at startup by ups, but not written.
Also, breakpoints in the
<TT>.config</TT>
file are automatically restored on startup.

<p>
In future releases you will be able to use the
<TT>.config</TT>
file to add environment variable settings, <i>etc.</i>
Currently the only directive
(other than things specifying breakpoints, saved variable and signal state) is
<TT>auto-start</TT>
which takes a single argument
<TT>yes</TT>
or
<TT>no</TT>.
The line :
<blockquote>
<PRE>
auto-start yes
</PRE>
</blockquote>
in the
<I>xxx</I><tt>.config</tt>
file means start the target running as soon as
<I>ups</I> has started up.

<p>
<i>Ups</i> also looks for saved state in the file
<TT>$HOME/.upsrc</TT>
and
<TT>.upsrc</TT>
(in the current directory).
Thus the full set of files is :
<blockquote>
<tt>$HOME/.upsrc</tt>
<br>
<tt>.upsrc</tt>
<br>
<tt>ups-state/</tt><I>xxx</I><tt>.config</tt>
<br>
<tt>ups-state/</tt><I>xxx</I><tt>.state</tt>
</blockquote>
Files later in the sequence can override earlier settings.
</P>

<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->

<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<a name="LOADING AND SAVING BREAKPOINTS"><H3>LOADING AND SAVING BREAKPOINTS</H3></a>
</td></tr></table>

<p>
You can explicitly load and save breakpoints to files.
To save
breakpoints, select one or more in the display area, then
select <b>Save</b> from the menu.
You will be prompted for a file name.
If the file already exists you will be asked whether
you want to cancel the save, overwrite the file or append to it.
The submenu controls whether breakpoints loaded this way
get saved in a statefile.

<p>
Saved breakpoints can be reloaded by selecting
<B>Load File</B>
and then
<B>Load - bpts NOT saved in statefile</B>
or
<B>Load - bpts saved in statefile</B>
from the
<B>Breakpoints</B>
header menu.
</P>

<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->

<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<a name="SEE ALSO"><H3>SEE ALSO</H3></a>
</td></tr></table>

<p>
<i>cc(1), f77(1), ld(1), dbx(1), gdb(1)</i>
</P>

<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->

<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<a name="BUGS"><H3>BUGS</H3></a>
</td></tr></table>

<p>
On the SPARC you can&acute;t step or next through the return statement
of a function returning a struct or union (functions returning
<I>pointers</I> to structs or unions work fine).
This is due to the peculiar and undocumented protocol that the
SPARC uses for returning structs and unions by value.

<p>
On the SPARC you get surprising behaviour if you use in interpreted
code a struct or union that is a formal parameter.
Your interpreted code must be written as if the variable is a
<I>pointer</I> to a struct rather than a struct.
This is again due to the SPARC structure passing protocol.

<p>
The SPARC C compiler emits an inline loop to implement structure
assignmemt for large structs.
Because of the way next and step are implemented in
<I>ups</I> you have to hit
<B>Next</B>
or
<B>Step</B>
several times to step over a line containing such a struct assignment.
Workaround: use
<B>Execute to here</B>
to get to the next line.

<p>
If you change a binary while you are debugging it
<I>ups</I> will get very upset (read: will probably core dump with a fatal
error message).
This is unsatisfactory and will be fixed in a future release.

<p>
Core files dumped from dynamic executables are incomplete which means
that you can only examine the non shared parts of the binary.

<p>
The
<B>Stop</B>
button in the target menu doesn&acute;t work if you are hitting lots of
fragments of interpreted code that don&acute;t stop the target.
</P>

<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->

<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<a name="ACKNOWLEDGEMENTS"><H3>ACKNOWLEDGEMENTS</H3></a>
</td></tr></table>

<p>
The work to support Solaris 2 was made possible by the generous
support of the following people (in alphabetical order):

<blockquote>
<table>
<tr><td>Ian Edwards</td><td>Panorama Software Corporation</td></tr>
<tr><td>Paul Friberg</td><td>Incorporated Research Institutions for Seismology</td></tr>
<tr><td>Robert L. Prehn</td><td>AT&T Bell Labs</td></tr>
<tr><td>Daniel Quinlan</td><td>University of Colorado</td></tr>
<tr><td>Ricardo Telichevesky</td><td>Cadence Design Systems, Inc.</td></tr>
<tr><td>Frank Vernon</td><td>UC San Diego</td></tr>
</table>
</blockquote>

<p>
Special thanks to Dan Quinlan for all the work he put into
organising the project.

<p>
The regular expression matching algorithm was written by Ozan S. Yigit
of the Department of Computer Science, York University.
</P>

<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->

<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<a name="AUTHORS"><H3>AUTHORS</H3></a>
</td></tr></table>

<p>
<a href="M.T.Russell@ukc.ac.uk">Mark Russell</a>, University of Kent.
<br>
Original version for the ICL Perq and many of the important ideas
by <a href="mailto:J.D.Bovey@ukc.ac.uk">John Bovey</a>, University of Kent.
</P>

<hr>

<!-- XXXXXXXX ------------------------------------------------------------- -->

<table width=100% bgcolor=#ffffcc border=0 cellspacing=0><tr><td>&nbsp;</td></tr><tr><td align=center>
<a name="ENHANCEMENT AUTHORS"><H3>ENHANCEMENT AUTHORS</H3></a>
</td></tr></table>

<p>
Rod Armstrong, Schlumberger Tech,
(<A HREF="mailto:rod@san-jose.tt.slb.com">rod@san-jose.tt.slb.com</A>)
added :
<blockquote>symbol table fixes for SC3/4, g++ and cfront/clcc;
<br>C++ demangling for cfront, SC3/4 and g++;
<br>dynamic library support for Solaris;
<br>native port for Linux ELF (based on the a.out port done by Rick Sladkey);
<br>duplication of breakpoints for overloaded C++ methods;
<br>automatic deference of the "this" pointer in C++ code;
<br>messages when symbols are read in;
<br>Motif type scrolling direction if desired;
<br>colored variable and breakpoint text;
<br>attach and detach buttons;
<br>honoring of quit request from a window manager;
<br>autoscrolling on selecting text;
<br>activate, inactive and execute buttons for breakpoints;
<br>accelerators for the display window;
<br>custom menus;
<br>X resource for fixing stacks for Purify/Quantify;
<br>menu items to spawn an editor, show file paths and reload and rematch files;
<br>partial name completion for breakpoints;
<br>listing of matching breakpoint names;
<br>init file support;
<br>rescan of initialization file on reattach;
<br>format option for RWCString;
<br>special signal control for SIGSEGV or SIGBUS;
<br>support for multiple linked files;
<br>explicit save and load of state files;
<br>help facility;
<br>various bug fixes.
</blockquote>

<p>
Ian Edwards
(<A HREF="mailto:ian@concerto.demon.co.uk">ian@concerto.demon.co.uk</A>)
provided a patch for FreeBSD 2.2.6-STABLE, and
support for <i>long long</i> and <i>long double</i> data types.
He also maintains the web site for UPS at
<a href="http://www.concerto.demon.co.uk/UPS">www.concerto.demon.co.uk/UPS</a>.

<p>
Russ Browne, Applied MicroSystems
(<A HREF="mailto:russ@amc.com">russ@amc.com</A>)
added handling of symbol 
table information concerning base classes, vector tables, and static class 
members in SC4 and g++ object files. He also
contributed the <tt>UPS_FORMATS</tt> environment variable, control characters in
<tt>UPS_F*_STR</tt>s, bumping of array indicies on duplication,
and elastic formating of file names in the stack and breakpoint list.
The formating feature allows the file names to be visible for large
fonts, and when the debugger window is made quite narrow.
He also did the extended double click accelerators; typing line shortcuts;
shading of inactive and disabled breakpoints; added X resources
for multiclick time, and source window menu control; added a 
command line option to force <i>ups</i> to pass the full name of the target executable;
and a fix for the size of <tt>bool</tt> data types;

<p>
Daniel M. Quinlan
(<A HREF="mailto:danq@lemond.colorado.edu">danq@lemond.colorado.edu</A>)
supplied fixes for displaying
<i>structures</i> and <i>unions</i>, some Fortran variables and a fix for
<tt>unknown type</tt> in scanning SC4 symbol tables.

<p>
Callum Gibson
(<A HREF="mailto:callum@bain.oz.au">callum@bain.oz.au</A>)
contributed the save state code for signals.

<p>
Craig Amey
(<A HREF="mailto:craiga@MetaSW.com">craiga@MetaSW.COM</A>)
contributed a fix for 16bpp visuals.

<p>
<HR>
<TABLE width=100%><TR> <TD width=33%><I></I></TD> <TD width=33% align=center>UPS (1)</TD> <TD align=right width=33%><I>20 Feb 1997</I></TD> </TR></TABLE></A>
<small>
Generated by <A HREF="http://www.parallax.co.uk/~rolf/download/manServer.html">manServer</A> from ups.man using man macros.
Subsequently hacked about by <a href="ups@concerto.demon.co.uk">Ian Edwards</a>.</small>
</BODY></HTML>
